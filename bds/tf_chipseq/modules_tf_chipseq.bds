#!/usr/bin/env bds

include "modules_string.bds"

string PREFIX
string OUTPUT_DIR
string TMP_DIR
int NTHREADS_BWA
string BWA_INDEX_NAME
string BWA_PARAM
string MARKDUP
int MAPQ_THRESH
int NTHREADS_R
string R_SCRIPT
int NREADS
int NPEAK
int SPEAK
int NUM_CTL

string{} conf // config. file


void read_conf() {
	print( "\nReading configuration...\n" );

	conf = config("conf_tf_chipseq.txt")

	// general
	PREFIX 		= chk_slash( conf{ "PREFIX" } )
	OUTPUT_DIR	= mkdir_path( conf{ "OUTPUT_DIR" } )
	TMP_DIR 	= mkdir_path( conf{ "TMP_DIR" } )

	// bwa alignment
	NTHREADS_BWA 	= parse_int( conf{ "NTHREADS_BWA" } )
	BWA_INDEX_NAME 	= chk_file( conf{ "BWA_INDEX_NAME" }, ".bwt" ) // check if filename+".bwt" exists
	BWA_PARAM 		= rm_comment( conf{ "BWA_PARAM" } )

	// dupe remover
	MARKDUP 	= chk_file( conf{ "MARKDUP" }, "" )
	MAPQ_THRESH = parse_int( conf{ "MAPQ_THRESH" } )

	// peak calling
	NTHREADS_R 	= parse_int( conf{ "NTHREADS_R" } )
	R_SCRIPT 	= chk_file( conf{ "R_SCRIPT" }, "" )
	NREADS 		= parse_int( conf{ "NREADS" } )
	NPEAK 		= parse_int( conf{ "NPEAK" } )
	SPEAK 		= parse_int( conf{ "SPEAK" } )

	// # of control fastq data
	NUM_CTL 	= parse_int( conf{ "NUM_CTL" } )

	// print conf info
	for( string k : conf.keys() ) {
		if ( k.indexOf("//")>=0 ) { // if key is comment ignore
			continue
		}
		print( k + " = " + rm_comment( conf{k} ) + "\n" )
	}
}

void tasks_before_spp() { // align->post_align->xcor->self-pseudo-replicate, 
	
	for ( int ctl=0; ctl <= NUM_CTL; ctl++) { // iterate through fastqs (0: not control, 1~: controls)
		for ( int rep=1; rep <= 2; rep++) {
			par align_to_spr( ctl, rep ) // parallel jobs for each control and each replicate
		}
	}

	wait
}

void pspr() // pooled self pseudo replicate
{
	for ( int ctl=0; ctl <= NUM_CTL; ctl++) {
	 	par pool( ctl )
	}

	wait
}

void spp() {
	//wait
}

void idr() {
	//wait
}

void align_to_spr( int ctl, int rep ) {

	align_bwa( ctl, rep )
	post_align_filt( ctl, rep )
 	bam_to_tagalign( ctl, rep )
 	xcor( ctl, rep )
 	spr( ctl, rep )
}

void align_bwa( int ctl, int rep ) {

	fastqs := get_fastqs( ctl, rep )

	OFPREFIX := OUTPUT_DIR + "/" +PREFIX + "_CTL" + ctl + "_Rep" + rep

	if ( fastqs.size() == 2 ) { // if data is paired-end, therefore PE1 and PE2

		FASTQ_FILE_1 := fastqs[0]
		FASTQ_FILE_2 := fastqs[1]

		SAI_FILE_1 := "$OFPREFIX"+"_1.sai"
		SAI_FILE_2 := "$OFPREFIX"+"_2.sai"

		RAW_SAM_FILE := "$OFPREFIX.raw.sam.gz"

		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE := "$RAW_BAM_PREFIX.bam" //# To be stored
		BADCIGAR_FILE := "$TMP_DIR/badReads."+OFPREFIX.baseName()+".tmp"
		RAW_BAM_FILE_MAPSTATS := "$RAW_BAM_PREFIX.flagstat.qc" //# QC File

		// run for outputs

		dep( SAI_FILE_1 <- FASTQ_FILE_1, cpus := NTHREADS_BWA ) {
			sys bwa aln $BWA_PARAM -t $NTHREADS_BWA $BWA_INDEX_NAME $FASTQ_FILE_1 > $SAI_FILE_1
		}

		dep( SAI_FILE_2 <- FASTQ_FILE_2, cpus := NTHREADS_BWA ) {
			sys bwa aln $BWA_PARAM -t $NTHREADS_BWA $BWA_INDEX_NAME $FASTQ_FILE_2 > $SAI_FILE_2
		}

		wait

		dep( RAW_SAM_FILE <- [SAI_FILE_1, SAI_FILE_2] ) {
			sys bwa sampe $BWA_INDEX_NAME $SAI_FILE_1 $SAI_FILE_2 $FASTQ_FILE_1 $FASTQ_FILE_2 | gzip -c > $RAW_SAM_FILE
		}

		wait

		dep( [RAW_BAM_FILE, RAW_BAM_FILE_MAPSTATS] <- RAW_SAM_FILE ) {
			//# ==============================================================                                         
			//# Remove read pairs with bad CIGAR strings and sort by position                                                                
			//# ==============================================================
		 
			//# Find bad CIGAR read names                                                                                                                                                  
			sys	zcat $RAW_SAM_FILE | awk 'BEGIN {FS="\t" ; OFS="\t"} ! /^@/ && $6!="*" { cigar=$6; gsub("[0-9]+D","",cigar); n = split(cigar,vals,"[A-Z]"); s = 0; for (i=1;i<=n;i++) s=s+vals[i]; seqlen=length($10) ; if (s!=seqlen) print $1"t"; }' | sort | uniq > $BADCIGAR_FILE

			//# Remove bad CIGAR read pairs
			sys if [ $(cat $BADCIGAR_FILE | wc -l) -gt 0 ]; then zcat $RAW_SAM_FILE | grep -v -F -f $BADCIGAR_FILE | samtools view -Su - | samtools sort - $RAW_BAM_PREFIX; else samtools view -Su $RAW_SAM_FILE | samtools sort - $RAW_BAM_PREFIX; fi

			sys samtools flagstat $RAW_BAM_FILE > $RAW_BAM_FILE_MAPSTATS
			//sys rm $BADCIGAR_FILE $RAW_SAM_FILE
			//sys rm $SAI_FILE_1 $SAI_FILE_2
		}

		goal( RAW_BAM_FILE_MAPSTATS ) 

	}
	else if ( fastqs.size() == 1 ) { // single-end

		FASTQ_FILE_1 := fastqs[0]

		//# ========================================
		//# Map reads to create raw SAM file
		//# ========================================
		SAI_FILE_1 :="$OFPREFIX.sai"
		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE :="$RAW_BAM_PREFIX.bam" //# To be stored
		RAW_BAM_FILE_MAPSTATS :="$RAW_BAM_PREFIX.flagstat.qc" //# QC File

		dep( SAI_FILE_1 <- FASTQ_FILE_1, cpus := NTHREADS_BWA ) {
			sys bwa aln -q 5 -l 32 -k 2 -t $NTHREADS_BWA $BWA_INDEX_NAME $FASTQ_FILE_1 > $SAI_FILE_1
		}

		wait

		dep( RAW_BAM_FILE <- SAI_FILE_1 ) {
			sys bwa samse $BWA_INDEX_NAME $SAI_FILE_1 $FASTQ_FILE_1 | samtools view -Su - | samtools sort - $RAW_BAM_PREFIX
		}

		wait

		dep( RAW_BAM_FILE_MAPSTATS <- RAW_BAM_FILE ) {
			sys samtools flagstat $RAW_BAM_FILE > $RAW_BAM_FILE_MAPSTATS
			sys rm $SAI_FILE_1
		}

		goal( RAW_BAM_FILE_MAPSTATS )
	}
	else { // no data		
		print("align_bwa: no input for ctl $ctl, rep $rep\n")
	}

	wait
}

void post_align_filt( int ctl, int rep ) {

	fastqs := get_fastqs( ctl, rep )

	OFPREFIX := OUTPUT_DIR + "/" + PREFIX + "_CTL" + ctl + "_Rep" + rep

	if ( fastqs.size() == 2 ) { // if data is paired-end, therefore PE1 and PE2

		FILT_BAM_PREFIX :="$OFPREFIX.filt.srt"
		FILT_BAM_FILE :="$FILT_BAM_PREFIX.bam"

		TMP_FILT_BAM_PREFIX :="$FILT_BAM_PREFIX.nmsrt.tmp2"
		TMP_FILT_BAM_FILE :="$TMP_FILT_BAM_PREFIX.bam"
		
		TMP_FILT_BAM_FILE2 :="$FILT_BAM_PREFIX.dupmark.bam"
		DUP_FILE_QC :="$FILT_BAM_PREFIX.dup.qc"

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.srt.nodup"
		FINAL_BAM_FILE :="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_BAM_INDEX_FILE :="$FINAL_BAM_PREFIX.bai"
		FINAL_BAM_FILE_MAPSTATS :="$FINAL_BAM_PREFIX.flagstat.qc" //# QC file
		FINAL_NMSRT_BAM_PREFIX :="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE :="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE :="$RAW_BAM_PREFIX.bam" //# To be stored

		PBC_FILE_QC :="$FINAL_BAM_PREFIX.pbc.qc"

		dep( FILT_BAM_FILE <- RAW_BAM_FILE ) { 

			//# =============================
			//# Remove  unmapped, mate unmapped
			//# not primary alignment, reads failing platform
			//# Remove low MAPQ reads
			//# Only keep properly paired reads
			//# Obtain name sorted BAM file
			//# ==================
			sys samtools view -F 1804 -f 2 -q $MAPQ_THRESH -u $RAW_BAM_FILE | samtools sort -n - $TMP_FILT_BAM_PREFIX //# Will produce name sorted BAM
			
			//# Remove orphan reads (pair was removed)
			//# and read pairs mapping to different chromosomes
			//# Obtain position sorted BAM
			
			sys samtools fixmate -r $TMP_FILT_BAM_FILE - | samtools view -F 1804 -f 2 -u - | samtools sort - $FILT_BAM_PREFIX //# Will produce coordinate sorted BAM
		}

		wait

		dep( FINAL_BAM_FILE <- FILT_BAM_FILE ) {

			//# =============
			//# Mark duplicates
			//# =============

			sys java -Xmx4G -jar $MARKDUP INPUT=$FILT_BAM_FILE OUTPUT=$TMP_FILT_BAM_FILE2 METRICSFILE=$DUP_FILE_QC VALIDATIONSTRINGENCY=LENIENT ASSUMESORTED=true REMOVEDUPLICATES=false
			//sys mv $TMP_FILT_BAM_FILE2 $FILT_BAM_FILE

			//# ============================
			//# Remove duplicates
			//# Index final position sorted BAM
			//# Create final name sorted BAM
			//# ============================

			//sys samtools view -F 1804 -f 2 -b $FILT_BAM_FILE > $FINAL_BAM_FILE
			sys samtools view -F 1804 -f 2 -b $TMP_FILT_BAM_FILE2 > $FINAL_BAM_FILE
		}

		wait

		dep( FINAL_NMSRT_BAM_FILE <- FINAL_BAM_FILE ) {
			sys samtools sort -n $FINAL_BAM_FILE $FINAL_NMSRT_BAM_PREFIX
		}

		dep( [FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, PBC_FILE_QC] <- FINAL_BAM_FILE ) {

			//# Index Final BAM file
			sys samtools index $FINAL_BAM_FILE $FINAL_BAM_INDEX_FILE
			sys samtools flagstat $FINAL_BAM_FILE > $FINAL_BAM_FILE_MAPSTATS

			//# =============================
			//# Compute library complexity
			//# =============================
			//# Sort by name
			//# convert to bedPE and obtain fragment coordinates
			//# sort by position and strand
			//# Obtain unique count statistics
		
			//# TotalReadPairs [tab] DistinctReadPairs [tab] OneReadPair [tab] TwoReadPairs [tab] NRF=Distinct/Total [tab] PBC1=OnePair/Distinct [tab] PBC2=OnePair/TwoPair

			sys samtools sort -no $FILT_BAM_FILE - | bamToBed -bedpe -i stdin | awk 'BEGIN{OFS="\t"}{print $1,$2,$4,$6,$9,$10}' | grep -v 'chrM' | sort | uniq -c | awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > $PBC_FILE_QC

			//sys rm $FILT_BAM_FILE
			sys rm $TMP_FILT_BAM_FILE
			sys rm $TMP_FILT_BAM_FILE2
		}

		goal( PBC_FILE_QC )

		//[FINAL_BAM_FILE, FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, PBC_FILE_QC]
	}
	else if ( fastqs.size() == 1 ) { // single-end

		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE :="$RAW_BAM_PREFIX.bam"

		FILT_BAM_PREFIX :="$OFPREFIX.filt.srt"
		FILT_BAM_FILE :="$FILT_BAM_PREFIX.bam"

		TMP_FILT_BAM_FILE :="$FILT_BAM_PREFIX.dupmark.bam"
		DUP_FILE_QC :="$FILT_BAM_PREFIX.dup.qc" //# QC file

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE :="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_BAM_INDEX_FILE :="$FINAL_BAM_PREFIX.bai" //# To be stored
		FINAL_BAM_FILE_MAPSTATS :="$FINAL_BAM_PREFIX.flagstat.qc" //# QC file
		PBC_FILE_QC :="$FINAL_BAM_PREFIX.pbc.qc"

		//# =============================
		//# Remove  unmapped, mate unmapped
		//# not primary alignment, reads failing platform
		//# Remove low MAPQ reads
		//# ==================  

		dep( FILT_BAM_FILE <- RAW_BAM_FILE ) {
			sys samtools view -F 1804 -q $MAPQ_THRESH -b $RAW_BAM_FILE > $FILT_BAM_FILE
		}

		wait

		dep( FINAL_BAM_FILE <- FILT_BAM_FILE ) {
			//# ========================
			//# Mark duplicates
			//# ======================

			sys java -Xmx4G -jar $MARKDUP INPUT=$FILT_BAM_FILE OUTPUT=$TMP_FILT_BAM_FILE METRICS_FILE=$DUP_FILE_QC VALIDATION_STRINGENCY=LENIENT ASSUME_SORTED=true REMOVE_DUPLICATES=false
			//sys mv $TMP_FILT_BAM_FILE $FILT_BAM_FILE

			//# ============================
			//# Remove duplicates
			//# Index final position sorted BAM
			//# ============================
			//sys samtools view -F 1804 -b $FILT_BAM_FILE > $FINAL_BAM_FILE
			sys samtools view -F 1804 -b $TMP_FILT_BAM_FILE > $FINAL_BAM_FILE
		}

		wait

		dep( [FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, PBC_FILE_QC] <- FINAL_BAM_FILE ) {

			//# Index Final BAM file
			sys samtools index $FINAL_BAM_FILE $FINAL_BAM_INDEX_FILE

			sys samtools flagstat $FINAL_BAM_FILE > $FINAL_BAM_FILE_MAPSTATS

			//# =============================
			//# Compute library complexity
			//# =============================
			//# sort by position and strand
			//# Obtain unique count statistics

			//# PBC File output
			//# TotalReadPairs [tab] DistinctReadPairs [tab] OneReadPair [tab] TwoReadPairs [tab] NRF=Distinct/Total [tab] PBC1=OnePair/Distinct [tab] PBC2=OnePair/TwoPair

			// bedtools bamtobed -> bamToBed
			sys bamToBed -i $FILT_BAM_FILE | awk 'BEGIN{OFS="\t"}{print $1,$2,$3,$6}' | grep -v 'chrM' | sort | uniq -c | awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > $PBC_FILE_QC
			//sys rm $FILT_BAM_FILE
		}

		goal( PBC_FILE_QC )
	}
	else { // no data		
		print("post_align_filt: no input for ctl $ctl, rep $rep\n")
	}

	wait	
}

void bam_to_tagalign( int ctl, int rep ) {

	OFPREFIX := OUTPUT_DIR + "/" + PREFIX + "_CTL" + ctl + "_Rep" + rep
	NREADS_PER_MILLION := NREADS/1000000

	fastqs := get_fastqs( ctl, rep )

	if ( fastqs.size() == 2 ) { // if data is paired-end, therefore PE1 and PE2

	 	FINAL_BAM_PREFIX :="$OFPREFIX.filt.srt.nodup"
		FINAL_BAM_FILE :="$FINAL_BAM_PREFIX.bam"
		FINAL_TA_FILE :="$FINAL_BAM_PREFIX.PE2SE.tagAlign.gz"

		FINAL_NMSRT_BAM_PREFIX :="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE :="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		FINAL_BEDPE_FILE :="$FINAL_NMSRT_BAM_PREFIX.bedpe.gz"
		SUBSAMPLED_TA_FILE :="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz"

		dep( FINAL_TA_FILE <- FINAL_BAM_FILE ) {
			//# ===================
			//# Create tagAlign file
			//# ===================
		
			sys bamToBed -i $FINAL_BAM_FILE | awk 'BEGIN{OFS="\t"}{$4="N";$5="1000";print $0}' | gzip -c > $FINAL_TA_FILE
		}

		dep( [FINAL_BEDPE_FILE, SUBSAMPLED_TA_FILE] <- FINAL_NMSRT_BAM_FILE ) {

			//# ================
			//# Create BEDPE file
			//# ================

			sys bamToBed -bedpe -mate1 -i $FINAL_NMSRT_BAM_FILE | gzip -c > $FINAL_BEDPE_FILE

			//# =================================
			//# Subsample tagAlign file
			//# Restrict to one read end per pair for CC analysis
			//# ================================

			sys zcat $FINAL_BEDPE_FILE | grep -v "chrM" | shuf -n $NREADS | awk 'BEGIN{OFS="\t"}{print $1,$2,$3,"N","1000",$9}' | gzip -c > $SUBSAMPLED_TA_FILE
		}

		//wait

		goal( FINAL_TA_FILE ) 
		// goal( SUBSAMPLED_TA_FILE )
		//[FINAL_TA_FILE, FINAL_BEDPE_FILE, SUBSAMPLED_TA_FILE]
	}
	else if ( fastqs.size() == 1 ) { // single-end

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE :="$FINAL_BAM_PREFIX.bam" //# To be stored

		FINAL_TA_FILE :="$FINAL_BAM_PREFIX.SE.tagAlign.gz"
		SUBSAMPLED_TA_FILE :="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz"

//		task( [FINAL_TA_FILE, SUBSAMPLED_TA_FILE] <- FINAL_BAM_FILE ) { // bug; if dep is somewhere else in a function, 
		dep( [FINAL_TA_FILE, SUBSAMPLED_TA_FILE] <- FINAL_BAM_FILE ) { // task does not test <- operator properly, use dep instead

			//# ===================
			//# Create tagAlign file
			//# ===================
			//# Create SE tagAlign file

			// bedtools bamtobed -> bamToBed
			sys bamToBed -i $FINAL_BAM_FILE | awk 'BEGIN{OFS="\t"}{$4="N";$5="1000";print $0}' | gzip -c > $FINAL_TA_FILE

			//# =================================
			//# Subsample tagAlign file
			//# ================================

			sys zcat $FINAL_TA_FILE | grep -v "chrM" | shuf -n $NREADS | gzip -c > $SUBSAMPLED_TA_FILE
		}

		goal SUBSAMPLED_TA_FILE
	}
	else { // no data		
		print("bam_to_tagAlign: no input for ctl $ctl, rep $rep\n")
	}

	wait	
}

void xcor( int ctl, int rep ) {

	OFPREFIX := OUTPUT_DIR + "/" + PREFIX + "_CTL" + ctl + "_Rep" + rep
	NREADS_PER_MILLION := NREADS/1000000

	fastqs := get_fastqs( ctl, rep )

	if ( fastqs.size() == 0 ) { // if data is paired-end, therefore PE1 and PE2
		print("xcor: no input for ctl $ctl, rep $rep\n")
	}
	else {
		print("DEBUG: " + fastqs+"\n")

		string SUBSAMPLED_TA_FILE 

		if ( fastqs.size() == 2 ) { // if data is paired-end, therefore PE1 and PE2
			SUBSAMPLED_TA_FILE = "$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz"
		}
		else {
			SUBSAMPLED_TA_FILE = "$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz"
		}
		CC_SCORES_FILE :="$SUBSAMPLED_TA_FILE.cc.qc"
		CC_PLOT_FILE :="$SUBSAMPLED_TA_FILE.cc.plot.pdf"

		dep( [CC_SCORES_FILE, CC_PLOT_FILE] <- SUBSAMPLED_TA_FILE ) {

			//# CCSCORE FILE format
			//# Filename <tab> numReads <tab> estFragLen <tab> correstFragLen <tab> PhantomPeak <tab> corrphantomPeak <tab> argmincorr <tab> mincorr <tab> phantomPeakCoef <tab> relPhantomPeakCoef <tab> QualityTag

			//sys $R_SCRIPT $(which run_spp.R) -c=$SUBSAMPLED_TA_FILE -p=$NTHREADS -filtchr=chrM -savp=$CC_PLOT_FILE -out=$CC_SCORES_FILE
			//sys $R_SCRIPT $(which run_spp.R) -c=$SUBSAMPLED_TA_FILE -filtchr=chrM -savp=$CC_PLOT_FILE -out=$CC_SCORES_FILE
			sys $R_SCRIPT $(which run_spp.distinct.R) -c=$SUBSAMPLED_TA_FILE -filtchr=chrM -savp=$CC_PLOT_FILE -out=$CC_SCORES_FILE

			sys sed -r 's/,[^\t]+//g' $CC_SCORES_FILE > $OFPREFIX.tmp2
			sys mv $OFPREFIX.tmp2 $CC_SCORES_FILE
		}

		goal CC_SCORES_FILE
	}

	wait	
}

void spr( int ctl, int rep ) { // self-pseudo-replicate

	OFPREFIX := OUTPUT_DIR + "/" + PREFIX + "_CTL" + ctl + "_Rep" + rep

	fastqs := get_fastqs( ctl, rep )

	if ( fastqs.size() == 2 ) { // if data is paired-end, therefore PE1 and PE2

		FINAL_NMSRT_BAM_PREFIX :="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE :="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		FINAL_BEDPE_FILE :="$FINAL_NMSRT_BAM_PREFIX.bedpe.gz"

		PR_PREFIX :="$OFPREFIX.filt.nodup"
		PR1_TA_FILE :="$PR_PREFIX.PE2SE.pr1.tagAlign.gz"
		PR2_TA_FILE :="$PR_PREFIX.PE2SE.pr2.tagAlign.gz"

		dep( [PR1_TA_FILE, PR2_TA_FILE] <- FINAL_BEDPE_FILE ) {
		//# ========================
		//# Create pseudoReplicates
		//# =======================

		//# Get total number of read pairs
		//# Shuffle and split BEDPE file into 2 equal parts
		//# Will produce $PR_PREFIX00 and $PR_PREFIX01
			sys nlines=$( zcat $FINAL_BEDPE_FILE | wc -l ); nlines=$(( (nlines + 1) / 2 )); zcat $FINAL_BEDPE_FILE | shuf | split -d -l $((nlines)) - $PR_PREFIX. 

			//# Convert read pairs to reads into standard tagAlign file
			sys awk 'BEGIN{OFS="\t"}{printf "%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n",$1,$2,$3,$9,$4,$5,$6,$10}' "$PR_PREFIX.00" | gzip -c > $PR1_TA_FILE
			sys rm $PR_PREFIX.00
			sys awk 'BEGIN{OFS="\t"}{printf "%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n",$1,$2,$3,$9,$4,$5,$6,$10}' "$PR_PREFIX.01" | gzip -c > $PR2_TA_FILE
			sys rm $PR_PREFIX.01
		}

		goal PR2_TA_FILE
	}
	else if ( fastqs.size() == 1 ) {

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.nodup.srt"

		FINAL_TA_FILE :="$FINAL_BAM_PREFIX.SE.tagAlign.gz"

		PR_PREFIX :="$OFPREFIX.filt.nodup"
		PR1_TA_FILE :="$PR_PREFIX.SE.pr1.tagAlign.gz"
		PR2_TA_FILE :="$PR_PREFIX.SE.pr2.tagAlign.gz"

		dep( [PR1_TA_FILE, PR2_TA_FILE] <- FINAL_TA_FILE ) {
			//# ========================
			//# Create pseudoReplicates
			//# =======================

			//# Get total number of read pairs
			//# Shuffle and split BEDPE file into 2 equal parts
			//# Will produce $PR_PREFIX00 and $PR_PREFIX01
			sys nlines=$( zcat $FINAL_TA_FILE | wc -l ); nlines=$(( (nlines + 1) / 2 )); zcat $FINAL_TA_FILE | shuf | split -d -l $((nlines)) - $PR_PREFIX.

			//# Convert read pairs to reads into standard tagAlign file
			sys gzip -c $PR_PREFIX.00 > $PR1_TA_FILE
			sys rm $PR_PREFIX.00
			sys gzip -c $PR_PREFIX.01 > $PR2_TA_FILE
			sys rm $PR_PREFIX.01
		}

		goal PR2_TA_FILE
	}
	else { // no data				
		print("spr: no input for ctl $ctl, rep $rep\n")
	}

	wait	
}

void pool( int ctl ) {

	DATASET_PREFIX := OUTPUT_DIR + "/" +PREFIX + "_CTL" + ctl
	
	fastqs_Rep2 := get_fastqs( ctl, 2 ) // check if rep2 doesn't exist

	if ( fastqs_Rep2.size() == 0 ) { // no rep2 (particularly for some controls)

        REP1_TA_FILE :="$DATASET_PREFIX_Rep1.filt.srt.nodup.PE2SE.tagAlign.gz"
        REP2_TA_FILE :="$DATASET_PREFIX_Rep2.filt.srt.nodup.PE2SE.tagAlign.gz"

        POOLED_TA_FILE :="$DATASET_PREFIX_Rep0.filt.srt.nodup.PE2SE.tagAlign.gz"

        REP1_PR1_TA_FILE :="$DATASET_PREFIX_Rep1.filt.nodup.PE2SE.pr1.tagAlign.gz"
        REP1_PR2_TA_FILE :="$DATASET_PREFIX_Rep1.filt.nodup.PE2SE.pr2.tagAlign.gz"

        REP2_PR1_TA_FILE :="$DATASET_PREFIX_Rep2.filt.nodup.PE2SE.pr1.tagAlign.gz"
        REP2_PR2_TA_FILE :="$DATASET_PREFIX_Rep2.filt.nodup.PE2SE.pr2.tagAlign.gz"

        PPR1_TA_FILE :="$DATASET_PREFIX_Rep0.filt.nodup.PE2SE.pr1.tagAlign.gz"
        PPR2_TA_FILE :="$DATASET_PREFIX_Rep0.filt.nodup.PE2SE.pr2.tagAlign.gz"

        dep( POOLED_TA_FILE <- [REP1_TA_FILE, REP2_TA_FILE] ) {
            //# ========================
            //# Create pooled datasets
            //# =======================
            sys zcat $REP1_TA_FILE $REP2_TA_FILE | gzip -c > $POOLED_TA_FILE
        }

        dep( PPR1_TA_FILE <- [REP1_PR1_TA_FILE, REP2_PR1_TA_FILE] ) {

            //# ========================
            //# Create pooled pseudoreplicates
            //# =======================
            sys zcat $REP1_PR1_TA_FILE $REP2_PR1_TA_FILE | gzip -c > $PPR1_TA_FILE
        }

        dep( PPR2_TA_FILE <- [REP1_PR2_TA_FILE, REP2_PR2_TA_FILE] ) {
            sys zcat $REP1_PR2_TA_FILE $REP2_PR2_TA_FILE | gzip -c > $PPR2_TA_FILE
        }
        
        goal PPR2_TA_FILE
	}
	else if ( fastqs.size() == 1 ) { 
	}
	else {
		print("pspr: no input for ctl $ctl, rep $rep\n")
	}
	wait

}

string[] get_fastqs( int ctl, int rep ) { 
	// if paired-end return [PE1, PE2], elseif single-end else return [PE1], else []
	string[] ret

	for ( int pe=1; pe<=2; pe++ ) {
		str := get_fastq( ctl, rep, pe )

		if ( str.length() > 0 ) { // if not null, append
			ret.add( str )
		}
	}

	return ret
}

string get_fastq( int ctl, int rep, int pe ) {
	string key = ( ctl > 0 ? "INPUT_FASTQ_CTL" + ctl : "INPUT_FASTQ" ) + "_REP" + rep + "_PE" + pe

	if ( conf.hasKey( key ) ) {
		return get_path( conf{ key }.trim() )
	}
	else {
		return ""
	}
}

#!/usr/bin/env bds


string chk_slash( string str ) { // if slash found, error
	trimmed := rm_comment( str )
	if ( trimmed.indexOf("/")>=0 ) {
		error("error: path including / not allowed for $str\n")
	}
	return trimmed
}

string chk_file( string str, string ext ) {
	path := get_path( str )
	path_ext := path + ext

	if ( !path_ext.exists() ) {
		error("error: file does not exist for $path_ext\n")
	}
	else if ( path_ext.isDir() ) {
		error("error: need file instead of dir for $path_ext\n")
	}
	else if ( path_ext.isFile() ) {
		return path
	}
	else {
		error("error: unknown error for $path_ext\n")
	}
}

string mkdir_path( string str ) { 
	// make filename full path and mkdir -p
	path := get_path( str )

	if ( path.exists() ) {		
		return path
	}
	else if ( path.mkdir() ) {
		return path
	}
	else {
		error("error: could not make for $path\n")
	}
}

string get_path( string str ) {
	base := rm_str_at_end( str, "/" ).path()
	return base
	//ret := (base.indexOf(ppwd)==0) ? base.replace(ppwd,".") : base
	//print("$base, $ppwd, $ret\n")
	//return ret
}

string rm_str_at_end( string str, string rm ) {
	trimmed := rm_comment( str )
	if ( trimmed.substr( trimmed.length()-rm.length() ) == rm ) { // if "/" exists at the end of the string
		return trimmed.substr( 0, trimmed.length()-rm.length() )
	}
	
	return trimmed
}

string rm_comment( string str ) { // remove substring after double slash "//"
	trimmed := str.trim()
	int pos = trimmed.indexOf("//")

    if ( pos>=0 ) {
		return trimmed.substr(0,pos-1).trim()
	}

	return trimmed
}

int parse_int( string str ) {
	return rm_comment( str ).parseInt()
}

bool parse_bool( string str ) {
	return rm_comment( str ).parseBool()
}

real parse_real( string str ) {
	return rm_comment( str ).parseReal()
}



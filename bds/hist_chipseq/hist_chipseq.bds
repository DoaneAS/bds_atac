#!/usr/bin/env bds

include "../conf_general.bds"
include "../modules_align_map.bds"

// parameters and help
int NPEAK=300000 				help Parameter for -npeak in run_spp.R (default: 300000)
bool DUPE_REMOVED=true	 		help Set it true if dupes are removed when aligning (default: true)

string IDR_THRESH=0.02			help IDR thresh (default: 0.02)



// pipeline starts here

//read_param_general()
read_param_align_map()
read_param_tf_chipseq()

align_map_xcor_spr_pspr()
spp_idr()

exit(0)


// functions
void read_param_tf_chipseq() {

	// read parameters
	if ( CONF_FILE=="" ) {

	} 
	else if ( CONF_FILE.exists() ) {
		// peak calling (run_spp.R)
		NPEAK 			= parse_int( conf{ "NPEAK" } )
		DUPE_REMOVED	= parse_bool( conf{ "DUPE_REMOVED"} )
			RUN_SPP 	= DUPE_REMOVED ? "run_spp_nodups.R" : "run_spp.R"

		// IDR
		IDR_THRESH		= parse_real( conf{ "IDR_THRESH"} )
	}

	print("NREADS = $NREADS\n");
	print("NPEAK = $NPEAK\n");
	print("DUPE_REMOVED = $DUPE_REMOVED\n");
	print("NTHREADS_RUN_SPP = $NTHREADS_RUN_SPP\n");
	print("IDR_THRESH = $IDR_THRESH\n");
}

void spp_idr() {
	
	if ( QC_ONLY ) return

	print( "\nSPP and IDR...\n" );

	// SPP

	FRAGLEN := get_fraglen( 0, 1 ) // get it from rep1
	print("FRAGLEN for spp: $FRAGLEN \n")
	
	// prepare for tagAlign files
	fastqs_Rep1 	:= get_fastqs( conf, 0, 1 )
	fastqs_Rep2 	:= get_fastqs( conf, 0, 2 ) // check if rep2 doesn't exist
	suffix_PE 		:= ".filt.srt.nodup.PE2SE.tagAlign.gz"
	suffix_SE 		:= ".filt.nodup.srt.SE.tagAlign.gz"
	suffix 			:= fastqs_Rep1.size()==2 ? suffix_PE : suffix_SE
	suffix_PSR_PE 	:= ".filt.nodup.PE2SE"
	suffix_PSR_SE 	:= ".filt.nodup.SE"
	suffix_PSR 		:= fastqs_Rep1.size()==2 ? suffix_PSR_PE : suffix_PSR_SE

	DATASET_PREFIX := get_ofprefix( 0 )
	
	REP1_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix
	REP2_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix
	POOLED_TA_FILE :="$DATASET_PREFIX"+"_Rep0.tagAlign.gz"
	REP1_PR1_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix_PSR + ".pr1.tagAlign.gz"
	REP1_PR2_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix_PSR + ".pr2.tagAlign.gz"
	REP2_PR1_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix_PSR + ".pr1.tagAlign.gz"
	REP2_PR2_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix_PSR + ".pr2.tagAlign.gz"
	PPR1_TA_FILE :="$DATASET_PREFIX"+"_Rep0.pr1.tagAlign.gz"
	PPR2_TA_FILE :="$DATASET_PREFIX"+"_Rep0.pr2.tagAlign.gz"

	ctl_fastqs_Rep1 	:= get_fastqs( conf, 1, 1 )
	ctl_fastqs_Rep2 	:= get_fastqs( conf, 1, 2 ) // check if rep2 doesn't exist
	ctl_suffix_PE 		:= ".filt.srt.nodup.PE2SE.tagAlign.gz"
	ctl_suffix_SE 		:= ".filt.nodup.srt.SE.tagAlign.gz"
	ctl_suffix 			:= ctl_fastqs_Rep1.size()==2 ? ctl_suffix_PE : ctl_suffix_SE
	ctl_suffix_PSR_PE 	:= ".filt.nodup.PE2SE"
	ctl_suffix_PSR_SE 	:= ".filt.nodup.SE"
	ctl_suffix_PSR 		:= ctl_fastqs_Rep1.size()==2 ? ctl_suffix_PSR_PE : ctl_suffix_PSR_SE

	CTL_DATASET_PREFIX := get_ofprefix( 1 )

	CTL_REP1_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep1" + ctl_suffix
	CTL_REP2_TA_FILE := ctl_fastqs_Rep2.size()>0 ? "$CTL_DATASET_PREFIX"+"_Rep2" + ctl_suffix : CTL_REP1_TA_FILE
	CTL_POOLED_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep0.tagAlign.gz"
	CTL_REP1_PR1_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep1" + ctl_suffix_PSR + ".pr1.tagAlign.gz"
	CTL_REP1_PR2_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep1" + ctl_suffix_PSR + ".pr2.tagAlign.gz"
	CTL_REP2_PR1_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep2" + ctl_suffix_PSR + ".pr1.tagAlign.gz"
	CTL_REP2_PR2_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep2" + ctl_suffix_PSR + ".pr2.tagAlign.gz"
	CTL_PPR1_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep0.pr1.tagAlign.gz"
	CTL_PPR2_TA_FILE :="$CTL_DATASET_PREFIX"+"_Rep0.pr2.tagAlign.gz"

	PEAK_OUTPUT_DIR := OUTPUT_DIR + "/peaks"
	PEAK_OUTPUT_DIR.mkdir() 

	PEAK_REP1_CCSCORE := PEAK_OUTPUT_DIR + "/" + REP1_TA_FILE.baseName() + ".ccscores"
	PEAK_REP2_CCSCORE := PEAK_OUTPUT_DIR + "/" + REP2_TA_FILE.baseName() + ".ccscores"
	PEAK_POOLED_CCSCORE := PEAK_OUTPUT_DIR + "/" + POOLED_TA_FILE.baseName() + ".ccscores"

	// REP1_TA_FILE vs CTL_REP1_TA_FILE
	task( taskName := "spp rep1", cpus := NTHREADS_RUN_SPP, timeout := WALLTIME, mem := MEMORY, \
		PEAK_REP1_CCSCORE <- [REP1_TA_FILE, CTL_REP1_TA_FILE] ) {

		sys $PRELOAD
		
		sys Rscript $(which $RUN_SPP) -c=$REP1_TA_FILE -p=$NTHREADS_RUN_SPP -i=$CTL_REP1_TA_FILE \
			-npeak=300000 -odir=$PEAK_OUTPUT_DIR -speak=$FRAGLEN -savn -savr -savp -rf -out=$PEAK_REP1_CCSCORE
	}

	// REP2_TA_FILE vs CTL_REP2_TA_FILE
	task( taskName := "spp rep2", cpus := NTHREADS_RUN_SPP, timeout := WALLTIME, mem := MEMORY, \
		PEAK_REP2_CCSCORE <- [REP2_TA_FILE, CTL_REP2_TA_FILE]  ) {

		sys $PRELOAD
		
		sys Rscript $(which $RUN_SPP) -c=$REP2_TA_FILE -p=$NTHREADS_RUN_SPP -i=$CTL_REP2_TA_FILE \
			-npeak=300000 -odir=$PEAK_OUTPUT_DIR -speak=$FRAGLEN -savn -savr -savp -rf -out=$PEAK_REP2_CCSCORE
	}

	// POOLED_TA_FILE vs CTL_POOLED_TA_FILE
	task( taskName := "spp pooled", cpus := NTHREADS_RUN_SPP, timeout := WALLTIME, mem := MEMORY, \
		PEAK_POOLED_CCSCORE <- [POOLED_TA_FILE, CTL_POOLED_TA_FILE] ) {

		sys $PRELOAD
		
		sys Rscript $(which $RUN_SPP) -c=$POOLED_TA_FILE -p=$NTHREADS_RUN_SPP -i=$CTL_POOLED_TA_FILE \
			-npeak=300000 -odir=$PEAK_OUTPUT_DIR -speak=$FRAGLEN -savn -savr -savp -rf -out=$PEAK_POOLED_CCSCORE
	}

	wait

	// IDR


	REP1_NPEAK_FILE_BASE	:= rm_str_at_end( REP1_TA_FILE.baseName(),".gz" ) \
								 + "_VS_" + rm_str_at_end( CTL_REP1_TA_FILE.baseName(),".gz" ) + ".narrowPeak.gz"
	REP2_NPEAK_FILE_BASE 	:= rm_str_at_end( REP2_TA_FILE.baseName(),".gz" ) \
								 + "_VS_" + rm_str_at_end( CTL_REP2_TA_FILE.baseName(),".gz" ) + ".narrowPeak.gz"
	POOLED_NPEAK_FILE_BASE	:= rm_str_at_end( POOLED_TA_FILE.baseName(),".gz" ) \
								 + "_VS_" + rm_str_at_end( CTL_POOLED_TA_FILE.baseName(),".gz" ) + ".narrowPeak.gz"

	REP1_PEAK_FILE 	:= "$PEAK_OUTPUT_DIR/"+ REP1_NPEAK_FILE_BASE
	REP2_PEAK_FILE 	:= "$PEAK_OUTPUT_DIR/"+ REP2_NPEAK_FILE_BASE
	POOLED_PEAK_FILE:= "$PEAK_OUTPUT_DIR/"+ POOLED_NPEAK_FILE_BASE

	IDR_OUTPUT := "$PEAK_OUTPUT_DIR/REP1_VS_REP2.IDR" + IDR_THRESH +".narrowPeak"

	// Nathan's idr code
	task( taskName := "IDR", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY, \
		IDR_OUTPUT <- [REP1_PEAK_FILE, REP2_PEAK_FILE, POOLED_PEAK_FILE] ) { // --use-old-output-format 

		sys $PRELOAD

		sys idr --samples $REP1_PEAK_FILE $REP1_PEAK_FILE --peak-list $POOLED_PEAK_FILE --input-file-type narrowPeak \
			--output-file $IDR_OUTPUT --plot --idr-threshold $IDR_THRESH

		sys echo NPEAKS_IDR: $(cat $IDR_OUTPUT | wc -l)
	}

	wait
}

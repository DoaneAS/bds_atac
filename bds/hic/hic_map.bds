#!/usr/bin/env bds

include "hic_base.bds"

help Fastq paths
help         -fastq[Library_ID]_[Replicate_ID]_[Pair_ID] [FASTQ_FILE_PATH]
help         or
help         -fastq_L[Library_ID]_R[Replicate_ID]_P[Pair_ID] [FASTQ_FILE_PATH]

help Mapping settings
num_mismatch 	:= 2		help # of mismatches (default: 2).
nth_bwa 	:= 2 		help # threads for bwa (default: 2).
wt_bwa 		:= "10G" 	help Max. memory for bwa (default: 10G).
mem_bwa 	:= "40h" 	help Walltime for bwa (default: 40h, 40:00:00).


help()

init_hic_map()

chk_input_data()

set_shell_env()

map()

stat() // gather all stats in stat directory



void init_hic_map() {

	if ( conf_file_exists() ) {
		num_mismatch 	= get_conf_val_int( num_mismatch, 	["num_mismatch", "nummismatch"] )
		nth_bwa 	= get_conf_val_int( nth_bwa,		["nthreads_bwa", "nth_bwa", "cpu_bwa"] )
		wt_bwa 		= get_conf_val( wt_bwa, 		["walltime_bwa", "wt_bwa", "timeout_bwa"] )
		mem_bwa 	= get_conf_val( mem_bwa, 		["memory_bwa", "mem_bwa"] )
	}

	if ( v ) { // verbose
		print("\n")
		print( "# of mismatches\t\t: $num_mismatch\n" )
		print( "BWA index\t\t: $bwa_idx\n")
		print( "# threads (bwa)\t\t: $nth_bwa\n")
		print( "Walltime (bwa)\t\t: $wt_bwa\n")
		print( "Max. memory (bwa)\t: $mem_bwa\n")
	}

	// for unix sorting and joining 
	SHCMD_INIT = SHCMD_INIT + " LC_COLLATE=C; LC_ALL=C; LANG=C;" 
}


void chk_input_data() {

	if ( !("$bwa_idx.bwt").exists() ) error("\nBWA index doesn't exists!\n")

	print("\nChecking fastqs...\n\n")

	string[] fastqs_all

	for ( int lib=1; lib <= num_lib; lib++) {	
		for ( int rep=1; rep <= num_rep; rep++) {

			fastqs := get_fastqs_hic( lib, rep )

			id := get_id( lib, rep )
			print("$id :\n")

			for ( string s : fastqs ) {
				print("\t$s\n")
				if ( (s != "") && !(s.exists()) ) error("\t\tFile not found!\n")
			}

			// check any duplicate input filename
			for ( string s : fastqs ) {
				if ( is_in_array( get_basename( s ), get_basename( fastqs_all ) ) ) \
					error( "\tFilename is duplicate for $id!\n")
			}

			fastqs_all = concat( fastqs_all, fastqs )
		}
	}
}

void map() {

	for (int lib=1; lib<=num_lib; lib++) {
		for (int rep=1; rep<=num_rep; rep++) {

			if ( no_par_job )   _map( lib, rep )
			else 		par _map( lib, rep )
		}
	}
}

//void _map_wo_step4( int lib, int rep ) {
void _map( int lib, int rep ) {

	id := get_id( lib, rep )

	// create output dir
	mapped_dir 	:= mkdir_path( "$out_dir/mappedReads/$id" )
	srt_mapped_dir 	:= mkdir_path( "$out_dir/sortedMappedReads/$id" )
	extracted_dir 	:= mkdir_path( "$out_dir/extractedPairs/$id" )			
	cleaned_dir 	:= mkdir_path( "$out_dir/cleanedPairs/$id" )

	fastqs := get_fastqs_hic( lib, rep ) // get fastqs

	sam1 := _map_step1_align( id + "_1", fastqs[0], mapped_dir )
	sam2 := _map_step1_align( id + "_2", fastqs[1], mapped_dir )

	wait // hold parallel

	mapped1 := _map_step2_sort( id + "_1", sam1, srt_mapped_dir )
	mapped2 := _map_step2_sort( id + "_2", sam2, srt_mapped_dir )

	wait 

	extracted_pairs{ id } = _map_step3_join_all_comb( id, mapped1, mapped2, extracted_dir )
	cleaned_pairs{ id } = _map_step4_remove_PCR_dups( id, extracted_pairs{ id }, cleaned_dir )
}

string _map_step1_align( string id, string fastq, string out_dir ) {

	prefix 	:= "$out_dir/$id" //change_dir( remove_ext( fastq, "fastq" ), out_dir )

	sai 	:= "$prefix.sai"
	sam 	:= "$prefix.sam"
	sam_gz 	:= "$sam.gz"

	in 	:= fastq
	out 	:= sam_gz

	task( taskName := "map1_aln "+id, cpus := nth_bwa, timeout := parse_time(wt_bwa), mem := parse_mem(mem_bwa), \
		out<-in ) {
	
		sys $SHCMD_INIT	

		sys bwa aln $bwa_idx -t $nth_bwa $fastq > $sai
		sys bwa samse $bwa_idx $sai $fastq > $sam
		sys gzip $sam
		sys rm -f $sai
	}

	return out
}

string _map_step2_sort( string id, string sam_gz, string out_dir ) {

	prefix 		:= "$out_dir/$id" //change_dir( remove_ext( sam_gz, "sam" ), out_dir )
	mapped 		:= "$prefix.mapped"
	non_mapped 	:= "$prefix.nonmapped"
	mapped_gz	:= "$prefix.mapped.gz"
	non_mapped_gz 	:= "$prefix.nonmapped.gz"
	stat 		:= "$prefix.stat"

	sam 		:= "$prefix.sam"// temp file 

	in 	:= sam_gz
	out 	:= mapped_gz //, non_mapped_gz, stat]

	task( taskName := "map2_srt "+id, cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT

		sys zcat $sam_gz > $sam

		sys samtools view -S -F 4 $sam \
			| awk '$14=="X0:i:1" &&  $5>=30 && $12=="XT:A:U" {split($1,id,"#"); split($13,editDistField,":"); if (editDistField[3] <= $num_mismatch) {print id[1]"\t"$2"\t"$3"\t"$4"\t"$10}}' \
			| sort -k 1,1 > $mapped
		//#count the number of aligned pairs
		sys f=`cat $mapped | wc -l `
		sys gzip $mapped

		//## perform the above for non-mapped pairs		
		sys samtools view -S -f 4 $sam \
			| awk '{split($1,id,"#"); print id[1]"\t"$2"\t"$3"\t"$4"\t"$10}' \
			| sort -k 1,1 > $non_mapped 
		sys n=`cat $non_mapped | wc -l `
		sys gzip $non_mapped

		//## mapped but not uniques or quality below 30s or mismatch above what we expect
		sys m=`samtools view -S -F 4 $sam \
			| awk '{split($13,editDistField,":"); if (editDistField[3] > $num_mismatch || $14!="X0:i:1" || $5<30 || $12!="XT:A:U") {print $1}}' \
			|  wc -l `
		sys total=$((${m}+${n}+${f}))
		
		//## write out the statistics of alignment 
		sys echo -e "# Total\tuniquelyMapped\tnonMapped\tmappedButNotQualified " > $stat 
		sys echo -e "$id\t${total}\t${f}\t${n}\t${m} " >> $stat

		sys rm -f $sam
	}
	return out
}

string _map_step3_join_all_comb( string id, string mapped1, string mapped2, string out_dir ) {

	prefix 		:= "$out_dir/$id"//remove_ext( get_common_basename( mapped1, mapped2 ), "mapped" )

	extracted  	:= "$prefix"+"_extractedPairs"
	extracted_gz  	:= "$extracted.gz"

	num_extracted 	:= "$prefix"+"_NumberOfExtractedPairs"

	in 	:= [mapped1, mapped2]
	out 	:= extracted_gz

	task( taskName := "map3_join "+id, cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {
	
		sys $SHCMD_INIT	

		sys join <(zcat -f $mapped1) <(zcat -f $mapped2) > $extracted
		sys n=`cat $extracted | wc -l `
		sys gzip $extracted
		sys echo -e "$id\t${n} " > $num_extracted
	}
	return out
}

string _map_step4_remove_PCR_dups( string id, string extracted_gz, string out_dir ) {

	prefix 		:= "$out_dir/$id"//change_dir( remove_ext( extracted_gz, "_extractedPairs" ), out_dir )

	cleaned 	:= "$prefix"+"_cleanedPairs"
	cleaned_gz 	:= "$prefix"+"_cleanedPairs.gz"

	extracted_tmp 	:= "$prefix"+"_extractedPairs.tmp"

	num_cleaned 	:= "$prefix"+"_NumberOfCleanedPairs"

	in 	:= extracted_gz
	out 	:= cleaned_gz

	task( taskName := "map4_rm_PCR_dups "+id, cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	
		
		sys zcat $extracted_gz > $extracted_tmp

		sys countBefore=`wc -l $extracted_tmp | awk '{print $1}' `

		sys python $(which sort_loci.py) $extracted_tmp 2 \
			| awk 'OFS="\t" {s1="+"; s2="+"; if ($2=="16") {s1="-"}; if ($6=="16") {s2="-"}; print $3, $4, s1, $7, $8, s2, $5, $9, $1}' \
			| sort -u -k1,6 \
			| awk 'OFS="\t" { print $9, $3, $1, $2, $7, $6, $4, $5, $8}' > $cleaned

		sys countAfter=`wc -l $cleaned | awk '{print $1}' `
		sys gzip $cleaned

		sys echo -e "lib\\tpairsBeforePCR\\tpairsAfterPCR" > $num_cleaned
		sys echo -e "$id\\t${countBefore}\\t${countAfter}" >> $num_cleaned

		sys rm -f $extracted_tmp
	}
	return out
}

void stat() {

	stat_out_dir 	:= mkdir_path( "$out_dir/stat" )

	map_stat_file 		:= "$stat_out_dir/SortedAlignment"
	extracted_stat_file 	:= "$stat_out_dir/NumberOfExtractedPairs"
	cleaned_stat_file 	:= "$stat_out_dir/NumberOfCleanedPairs"

	sys find $out_dir/extractedPairs/ -name "*NumberOfExtractedPairs" -type f -exec cat {} \; | sort -u > $extracted_stat_file || true

	sys find $out_dir/cleanedPairs/ -name "*NumberOfCleanedPairs" -type f -exec cat {} \; | sort -u | grep "pairsBeforePCR" > $cleaned_stat_file || true
	sys find $out_dir/cleanedPairs/ -name "*NumberOfCleanedPairs" -type f -exec cat {} \; | sort -u | grep -v "pairsBeforePCR" >> $cleaned_stat_file || true

	sys find $out_dir/sortedMappedReads/ -name "*.stat" -type f -exec cat {} \; | sort -u | grep "uniquely" > $map_stat_file || true
	sys find $out_dir/sortedMappedReads/ -name "*.stat" -type f -exec cat {} \; | sort -u | grep -v "uniquely" >> $map_stat_file || true
}

string[] get_fastqs_hic( int lib, int rep ) {  // if paired-end return [PE1, PE2], elseif single-end else return [PE1], else []	

	string[] ret
	for ( int pe=1; pe<=2; pe++ ) {
		str := get_fastq_hic( lib, rep, pe )
		if ( str.length() > 0 ) { // if not null, append
			ret.add( str )
		}
	}

	return ret
}

string get_fastq_hic( int lib, int rep, int pe ) {

	key := "fastq" + lib + "_" + rep + "_" + pe
	key2 := "fastq_L" + lib + "_R" + rep + "_P" + pe
	key3 := "fastq_R" + rep + "_L" + lib + "_P" + pe

	if ( cmd_line_arg_has_key( key ) ) {
		return get_cmd_line_arg_val( key )
	}
	else if ( cmd_line_arg_has_key( key2 ) ) {
		return get_cmd_line_arg_val( key2 )
	}	
	else if ( cmd_line_arg_has_key( key3 ) ) {
		return get_cmd_line_arg_val( key3 )
	}	
	else if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( conf.hasKey( key3 ) ) {
		return get_path( conf{ key3 } )
	}
	return ""
}


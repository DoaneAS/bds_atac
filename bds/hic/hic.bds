#!/usr/bin/env bds

include "hic_base.bds"

help HiC settings (mapped data)
help   There are two ways to define paths for mapped data (cleaned pairs)
help   1) Using Root directory of mapped data
root_mapped 	:= ""		help Root path for mapped data ('out_dir' of hic_map.bds) (default: blank).

help   2) Using paths for individual cleaned pairs
help      Cleaned pair paths
help         -cln_pair[Library_ID]_[Replicate_ID] [CLEANED_PAIR_FILE_PATH]
help         or
help         -cln_pair_L[Library_ID]_R[Replicate_ID] [CLEANED_PAIR_FILE_PATH]

help HiC settings (merge method and resolution)
merge 		:= 1 		help Method for merging replicates and libraries (0: no merge, 1: merge reps only, 2: merge reps and libs, default: 1).
res 		:= ""		help Resolution (comma separated integers) (eg. '10,8,5' , default: 10)

help HiC settings (step 1)
RE_file 	:= "" 		help RE file (default: blank).

help HiC settings (step 2 and 3)
blacklist 	:= ""		help Blacklist (default: blank).
read_len 	:= 51 		help Read Length (default: 51).

help HiC settings (step 4)
mapp_thres  	:= "0.5"	help Mappability threshold in step 4 (default: 0.5).
wt_hic4		:= "30h"	help Walltime for hic step4 (normalizing with using ICE) (default: 30h, 30:00:00).

help HiC settings (step 6)
no_of_bins	:= 200		help Number of bins (default: 200).
dist_up_thres 	:= 10000000 	help Dist up threshold (default: 10000000).
mapp_thres_hic6	:= 1 		help Minimum number of hits per locus that has to exist to call it mappable. (default: 1).
no_of_passes 	:= 1 		help Number of passes after the initial (before) fit. (default: 1) (after).
residual_factor := -1 		help How many times better residual is desired for splines compared to power-law fit. (default: -1).
org 		:= "human" 	help org (default: human).
ref 		:= "hg19"	help ref (default: hg19).
re 		:= "HindIII" 	help re (default: hindIII).


int[] resolution

string{} RE_sites // map of RE sites ( key=w(resolution) )
string{} RE_sites_mid // map of RE sites mid ( key=w(resolution) )
string{} biases // map of bias ( key=w(resolution) )

string{} clean_pairs_comb // merged and combined clean pairs



help()

init_hic()

find_mapped_data()

set_shell_env()

merge_cleaned_pairs()

hic()



void init_hic() {

	if ( conf_file_exists() ) {

		root_mapped 	= get_conf_val( root_mapped, 		["root_mapped"] )
		merge 		= get_conf_val_int( merge, 		["merge"] )
		res 		= get_conf_val( res, 			["res"] ) 
		RE_file 	= get_conf_val( RE_file, 		["RE_file","REfile"] )
		blacklist 	= get_conf_val( blacklist, 		["blacklist"] ) 
		read_len 	= get_conf_val_int( read_len, 		["read_len", "read_length", "readlen", "readlength"] )
		mapp_thres  	= get_conf_val( mapp_thres, 		["mapp_thres", "mapp_thres_hic4"] ) 
		no_of_bins	= get_conf_val_int( no_of_bins, 	["no_of_bins", "num_bin", "no_bin"] )
		dist_up_thres 	= get_conf_val_int( dist_up_thres, 	["dist_up_thres"] )

		mapp_thres_hic6	= get_conf_val_int( mapp_thres_hic6, 	["mapp_thres_hic6"] )
		no_of_passes 	= get_conf_val_int( no_of_passes, 	["no_of_passes"] )
		residual_factor = get_conf_val_int( residual_factor, 	["residual_factor"] )

		org 		= get_conf_val( org, 			["org"] )
		ref 		= get_conf_val( ref, 			["ref"] )
		re 		= get_conf_val( re, 			["re"] ) 

		wt_hic4 	= get_conf_val( wt_hic4, 		["walltime_hic4", "wt_hic4", "timeout_hic4"] )		
	}

	if ( v ) { // verbose
		print("\n")
		print( "Root for mapped data\t: $root_mapped\n" )
		print( "Merge method\t\t: $merge ( " + get_merge_method() + " )\n" )
		print( "Resolution\t\t: $res\n" )
		print( "RE file\t\t\t: $RE_file\n" )
		print( "Blacklist\t\t: $blacklist\n" )
		print( "Read Length\t\t: $read_len\n" )
		print( "Mappability threshold in step 4\t: $mapp_thres\n" )
		print( "Number of bins\t\t: $no_of_bins\n" )
		print( "Dist. up threshold\t: $dist_up_thres\n" )
		print( "Mappability threshold in step 6\t: $mapp_thres_hic6\n" )
		print( "Number of passes\t: $no_of_passes\n" )
		print( "Residual factor\t\t: $residual_factor\n" )
		print( "org\t\t\t: $org\n" )
		print( "ref\t\t\t: $ref\n" )
		print( "re\t\t\t: $re\n" )
		print( "Walltime (sort cln pairs)\t: $wt_hic4\n")
	}

	if ( res == "" ) {

		error("Define resolution array with '-res [COMMA_SEPARATED_INTEGERS]'. Example: '-res 10,100,200'\n\n")
	}
	else {
		// create resolution array
		_resolution := res.trim().replace(";",",").replace(":",",").split(",")

		for ( string w : _resolution ) {
			resolution.add( w.parseInt() )
		}
	}
}

void find_mapped_data() {

	if ( root_mapped != "" ) {
		print("\n\nReading cleaned pairs from root of mapped directory...\n\n")
	}
	else {
		print("\n\nReading cleaned pairs from command line or configuration file...\n\n")
	}

	for (int lib=1; lib<=num_lib; lib++) {
		for (int rep=1; rep<=num_rep; rep++) {

			id := get_id( lib, rep )

			string cleaned

			if ( root_mapped != "" ) {
				cleaned 	= "$root_mapped/cleanedPairs/$id/$id"+"_cleanedPairs.gz"
			}
			else {
				cleaned 	= get_cln_pair( lib, rep )
			}

			print("\t$id: $cleaned\n")
			if ( !cleaned.exists() ) error("\t\tFile doesn't exists!\n")

			cleaned_pairs{ id } 	= cleaned
		}
	}
}

void merge_cleaned_pairs() {  // return: key=id, val=comma-separated cleanedPairs files

	if ( merge == 0 ) { // no merge

		clean_pairs_comb = cleaned_pairs
	}
	else if ( merge == 1 ) { // merge rep only

		for (int lib=1;lib<=num_lib;lib++) {

			new_id := get_id( lib )

			for (int rep=1;rep<=num_rep;rep++) {

				id := get_id( lib, rep )

				if ( clean_pairs_comb.hasKey( new_id ) ) \
					clean_pairs_comb{ new_id } = clean_pairs_comb{ new_id } + "," + cleaned_pairs{ id }
				else \
					clean_pairs_comb{ new_id } = cleaned_pairs{ id }
			}
		}
	}
	else if ( merge == 2 ) { // merge rep and lib

		new_id := prefix

		for (int lib=1;lib<=num_lib;lib++) {

			for (int rep=1;rep<=num_rep;rep++) {

				id := get_id( lib, rep )

				if ( clean_pairs_comb.hasKey( new_id ) ) \
					clean_pairs_comb{ new_id } = clean_pairs_comb{ new_id } + "," + cleaned_pairs{ id }
				else \
					clean_pairs_comb{ new_id } = cleaned_pairs{ id }
			}
		}
	}

	print("\nMerge method: "+get_merge_method()+"\n")

	print("\nMerged cleaned pairs:\n\n")

	for( string id : clean_pairs_comb.keys() ) {
		print("\t$id: "+clean_pairs_comb{ id }+"\n")
	}
}

void hic() {

	for ( int w : resolution ) {

		if ( no_par_job )   _hic( w )
		else 		par _hic( w )
	}
}

void _hic( int w ) {

	// HiC_preprocess first (step 1 and 3)
	_hic_preprocess( w )

	wait

	// HiC_postprocess (step 2, 4, 5, 6)
	for( string id : clean_pairs_comb.keys() ) {

		if ( no_par_job )    _hic_postprocess( id, clean_pairs_comb{ id }, w )
		else 		 par _hic_postprocess( id, clean_pairs_comb{ id }, w )
	}

	if ( no_par_job ) wait
}

void _hic_preprocess( int w ) {

	info := "RE$w"

	// create output dir
	RE_site_dir 	:= mkdir_path( "$out_dir/RESites" )
	Bias_dir 	:= mkdir_path( "$out_dir/preprocessedForBias" )

	(RE_sites{"$w"}, RE_sites_mid{"$w"}) = _hic_step1( RE_file, w, RE_site_dir, info )
	wait

	biases{"$w"} = _hic_step3( RE_sites{"$w"}, w, Bias_dir, info )
}

void _hic_postprocess( string id, string clean_pairs_comb, int w ) {

	info := "RE$w $id"

	// create output dirs
	bfr_ice_dir	:= mkdir_path( "$out_dir/interactionCounts/beforeICE/RE$w")
	raw_contact_dir := mkdir_path( "$out_dir/Plots")
	aft_ice_dir	:= mkdir_path( "$out_dir/interactionCounts/afterICE/RE$w")
	plot_dir	:= mkdir_path( "$out_dir/Plots/RE$w")
	contact_dir	:= mkdir_path( "$out_dir/ContactsPerFragment/RE$w")

	hic_bfr_ice_dir := mkdir_path( "$out_dir/fit-hi-c-results/RE$w/beforeICE/$id")
	hic_aft_ice_dir := mkdir_path( "$out_dir/fit-hi-c-results/RE$w/afterICE/$id")

	hic_bfr_ice_std_dir := mkdir_path( "$out_dir/fit-hi-c-results_std/RE$w/beforeICE/$id")
	hic_aft_ice_std_dir := mkdir_path( "$out_dir/fit-hi-c-results_std/RE$w/afterICE/$id")

	// parse clean_pairs_comb (comma separated cleanedPairs files)
	cleaned := clean_pairs_comb.split(",")

	list_contacts_bfr_ice 	:= _hic_step2( id, cleaned, RE_sites{"$w"}, w, bfr_ice_dir, info )
	wait

	raw_contact_cnts 	:= _hic_step2a( id, list_contacts_bfr_ice, w, raw_contact_dir, info )	
	if ( no_par_job ) wait

	list_contacts_aft_ice_biases 	:= _hic_step4( id, list_contacts_bfr_ice, biases{"$w"}, aft_ice_dir, info )
	if ( no_par_job ) wait

	contacts_per_frag 	:= _hic_step5( id, list_contacts_bfr_ice, RE_sites_mid{"$w"}, contact_dir, info )
	wait

	dist_bias 		:= _hic_step4a( id, list_contacts_aft_ice_biases, w, plot_dir, info )
	if ( no_par_job ) wait

	_hic_step6( "beforeICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_bfr_ice_dir, info )

	_hic_step6( "afterICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_aft_ice_dir, info )

	_hic_step6a( "beforeICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_bfr_ice_std_dir, info )

	_hic_step6a( "afterICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_aft_ice_std_dir, info )
}

string _hic_step1( string REfile, int w, string out_dir, string info ) {
	//# write out file with RE fragments @ RE-resolution

	RE_site 	:= "$out_dir/REFrags.RE$w"
	RE_site_mid 	:= "$out_dir/REFragsMid.RE$w"

	in 	:= REfile
	out 	:= [RE_site, RE_site_mid]

	task( taskName := "hic1 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys python $(which get-contactCounts-atRESize.py) $REfile $w $RE_site $RE_site_mid
	}

	return out	
}


string _hic_step2( string id, string[] cleaned_pairs, string RE_site, int w, string out_dir, string info ) {
	//# step 2 operations:
	//#  - get contacts at fixed window size 
	prefix := "$out_dir/$id"

	cleaned_tmp 	:= prefix+"_cleanedPairs.tmp"

	IntrachrThres 	:= w*5000 //$(($w*5000)) # distance threshold for calculating intrachromosomal interactions

	IntSite1Temp := prefix+"_IntSite1Temp"
	IntSite2Temp := prefix+"_IntSite2Temp"
	Site1NoBlack := prefix+"_Site1NoBlack"
	Site2NoBlack := prefix+"_Site2NoBlack"
	Read1 := prefix+"_Read1"
	Read2 := prefix+"_Read2"

	list_contacts_bfr_ice 	:= prefix+"_ListOfContacts"
	list_contacts_bfr_ice_gz:= prefix+"_ListOfContacts.gz"

	in  	:= [RE_site];	for ( string file : cleaned_pairs ) in.add( file )
	out 	:= list_contacts_bfr_ice_gz

	cleaned_pairs_all := array_to_str( cleaned_pairs, " " )

	task( taskName := "hic2 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//# remove pairs separated closer than threshold, remove chrM
		//sys zcat $cleaned_pairs_all \
		//	| awk 'length($3)<=5 && length($7)<=5 {print}' | grep -v chrM \
		//	| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print $3,$4,$4+$read_len,$1}' t=$IntrachrThres \
		//	| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite1Temp
		//sys zcat $cleaned_pairs_all \
		//	| awk 'length($3)<=5 && length($7)<=5 {print}' | grep -v chrM \
		//	| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print $7, $8, $8+$read_len, $1}' t=$IntrachrThres \
		//	| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite2Temp

		sys zcat $cleaned_pairs_all \
			| grep -v chrM | awk 'length($3)<=5 && length($7)<=5 {print}' \
			| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print}' t=$IntrachrThres > $cleaned_tmp
		sys cat $cleaned_tmp | awk '{print $3,$4,$4+$read_len,$1}' \
			| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite1Temp
		sys cat $cleaned_tmp | awk '{print $7,$8,$8+$read_len,$1}' \
			| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite2Temp
		sys rm -f $cleaned_tmp

		//# remove reads that overlap with Black list 
		sys bedtools intersect -v -a $IntSite1Temp -b $blacklist > $Site1NoBlack
		sys bedtools intersect -v -a $IntSite2Temp -b $blacklist > $Site2NoBlack

		//# assign reads to RE fragments
		sys bedtools intersect -wao -a $Site1NoBlack -b $RE_site \
			| awk '{print  $1, $8, $4}'| sort -k3,3| uniq -f 2 \
			| awk '{print  $3, $1, $2}'| sort -k1,1 > $Read1

		sys bedtools intersect -wao -a $Site2NoBlack -b $RE_site \
			| awk '{print  $1, $8, $4}'| sort -k3,3| uniq -f 2 \
			| awk '{print  $3, $1, $2}'| sort -k1,1 > $Read2

		//# join two fragment reads and calculate unique pairs
		sys join $Read1 $Read2 \
			| awk '{if($2<$4 || ($2==$4 && $3<=$5)) print $2,$3,$4,$5; else print $4,$5,$2, $3}' \
			| sort | uniq -c \
			| awk 'OFS="\t"{print $2,$3,$4,$5,$1}' > $list_contacts_bfr_ice

		sys gzip $list_contacts_bfr_ice
		sys rm -f $IntSite1Temp $IntSite2Temp $Site1NoBlack $Site2NoBlack $Read1 $Read2
	}

	return out
}

string _hic_step2a( string id, string list_contacts_bfr_ice, int w, string out_dir, string info ) {
	
	prefix 		:= "$out_dir/$id"
	raw_contact_cnts := "$prefix"+"_RawContactCounts_RE$w"

	in 	:= list_contacts_bfr_ice
	out 	:= raw_contact_cnts

	task( taskName := "hic2a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT

		sys python $(which plot_ScatterContactCounts.py) $list_contacts_bfr_ice $id $w $raw_contact_cnts
	}

	return out
}

string _hic_step3( string RE_site, int w, string out_dir, string info ) {
	//# preprocess the genome to get mappability per window. Note: needs to be run only once for a particular resolution

        bias 	:= "$out_dir/$org-$ref.$re.RE$w"

        in 	:= RE_site
        out 	:= bias

	task( taskName := "hic3 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//sys python $(which mappability_from_bed.py) --regions $RE_site --read_length $read_len --out $bias
		sys python $(which mappability_from_bed.py) --regions $RE_site --read_length $read_len --out $bias --map_prefix $umap"/chr"
	}

	return out
}

string _hic_step4( string id, string list_contacts_bfr_ice, string bias, string out_dir, string info ) {
	//# step 4 operations:
	//#  - normalizes each library using sparse ICE implementation
	//#  - calculate biases for each window.

	prefix 	:= "$out_dir/$id"

	list_contacts_aft_ice 	:= "$prefix"+"_ListOfContacts_after_ICE"

	list_contacts_aft_ice_biases 	:= "$list_contacts_aft_ice.biases"
	list_contacts_aft_ice_biases_gz := "$list_contacts_aft_ice.biases.gz"

	in 	:= [list_contacts_bfr_ice, bias]
	out 	:= list_contacts_aft_ice_biases_gz

	//#additional variables: 
	norm := "l1" // # l1 or l2 norm

	task( taskName := "hic4 $info", cpus := nth, timeout := parse_time(wt_hic4), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys zcat $list_contacts_bfr_ice > $list_contacts_bfr_ice.temp
		sys cat $bias  > $bias.temp
		sys python $(which ICE-with-sparseMatrix.py) $list_contacts_bfr_ice.temp $bias.temp $norm $list_contacts_aft_ice $mapp_thres
		sys gzip $list_contacts_aft_ice $list_contacts_aft_ice_biases
		sys rm -rf $list_contacts_bfr_ice.temp $bias.temp
	}

	return out
}

string _hic_step4a( string id, string list_contacts_aft_ice_biases, int w, string out_dir, string info ) {

	prefix 		:= "$out_dir/$id"
	dist_bias 	:= "$prefix"+"_DistOfBiases"
	dist_bias_png 	:= "$prefix"+"_DistOfBiases.png"

	in 	:= list_contacts_aft_ice_biases
	out 	:= dist_bias_png

	task( taskName := "hic4a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//sys echo $lib $ref $org $re		
		sys python $(which plot_DistOfBiases.py) $list_contacts_aft_ice_biases $dist_bias $id $w
	}

	return out
}

string _hic_step5( string id, string list_contacts_bfr_ice, string RE_site_mid, string out_dir, string info ) {
	//#  - calculate total numbmer of contacts coming out of each window.

	prefix 		:= "$out_dir/$id"

	contacts_per_frag 	:= "$prefix"+"_ContactsPerFragment"
	contacts_per_frag_gz 	:= "$prefix"+"_ContactsPerFragment.gz"
	srt_contacts 		:= "$prefix"+"_SortedContacts"

	in 	:= [list_contacts_bfr_ice, RE_site_mid]
	out 	:= contacts_per_frag_gz

	task( taskName := "hic5 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys touch $contacts_per_frag.tmp
		sys zcat $list_contacts_bfr_ice | awk '{print $1, $2, $5}' > $contacts_per_frag.tmp
		sys zcat $list_contacts_bfr_ice | awk '{print $3, $4, $5}' >> $contacts_per_frag.tmp
		//sys sort -k 1,1 $tmp > $SortedContacts
		sys sort -k1,1 -k2n,2 $contacts_per_frag.tmp > $srt_contacts
		sys echo >> $srt_contacts
		sys cat $srt_contacts | gawk '($1==key1 && $2==key2) { sum+=$3} ($1 != key1 || $2 != key2) {if (NR>1){print key1, key2, sum} key1=$1; key2=$2; sum=$3}' > $contacts_per_frag.tmp
		sys python $(which MergeCounts.py) $RE_site_mid $contacts_per_frag.tmp $contacts_per_frag
		sys gzip $contacts_per_frag
		sys rm -f $contacts_per_frag.tmp $srt_contacts
	}
	return out
}

void _hic_step6( string before_after, string id, \
		string list_contacts_bfr_ice, string list_contacts_aft_ice_biases, string contacts_per_frag, int w, string out_dir, string info ) {
	//#  - perform fit-hi-c on data before and after ICE
	//#  - places results into $PROJDIR/data/fit-hi-c-results
	prefix 		:= "$out_dir/$id"

	distLowThres := w*5000 //$(($w*5000))

	log := "$prefix"+"_log.conf.file"
	html := "$prefix"+"_fithic.html"

	in 	:= [list_contacts_bfr_ice, list_contacts_aft_ice_biases, contacts_per_frag]
	out 	:= [log, html]

	task( taskName := "hic6 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys discBinsize=$(($(($dist_up_thres-$distLowThres))/$no_of_bins))
		sys echo ${discBinsize}

		sys date >> $log
		sys echo w=$w no_of_bins=$no_of_bins mapp_thres_hic6=$mapp_thres_hic6 no_of_passes=$no_of_passes dist_up_thres=$dist_up_thres distLowThres=$distLowThres discBinsize=${discBinsize} residual_factor=$residual_factor>> $log 
		sys echo >> $log

		sys echo '<html>' > $html
		sys echo '<head><meta http-equiv= "content-type" content="text/html; charset=UTF-8"><title></title></head>' >> $html
		sys echo '<body>' >> $html
		sys echo '<table  border="1" >' >> $html
		sys echo '<tbody>' >> $html

		sys echo '<tr>' >> $html
		sys echo '<th scope="col"> Library label </th>' >> $html

		sys for t in `seq $(($no_of_passes+1))`; do \
			#echo '<th scope="col"> Equal occupancy binning </th>' >> $html; \
			echo '<th scope="col"> Fitting - power-law </th>' >> $html; \
			echo '<th scope="col"> Fitting - spline </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - power-law </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - spline </th>' >> $html; \
			echo '<th scope="col"> FDR - compare all </th>' >> $html; \
			echo '<th scope="col"> FDR - spline </th>' >> $html; \
			echo '<th scope="col"> Binning bias </th>' >> $html; \
			done

		sys echo '</tr>' >> $html

		sys noOfCols=$((($no_of_passes+1)*7))
		sys echo '<tr>' >> $html
		sys echo '<th> </th>' >> $html
		sys for t in `seq ${noOfCols}`; do \
			echo '<th> ${t} </th>' >> $html; \
			done
		sys echo '</tr>' >> $html

		sys if [[ $before_after == "afterICE" ]]; then \
			# REMOVED -d and -r and comparisonMode \
			python $(which fit-hic-LATEST.py) -l $id -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out \
	  		#python $(which fit-hi-c.py) -l $id -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes  -o $out_dir  > $out_dir/$id.out; \
			else \
			python $(which fit-hic-LATEST.py) -l $id -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out \
	  		#python $(which fit-hi-c.py) -l $id -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes  -o $out_dir > $out_dir/$id.out; \
			fi

		sys echo '<tr>' >> $html
		sys echo '<td> $id </td>' >> $html
		sys for t in `seq $(($no_of_passes+1))`; do \
			echo '<td> <a href="$id.plaw_pass${t}.png"><img src="$id.plaw_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass${t}.png"><img src="$id.spline_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.plaw_pass${t}.extractOutliers.png"><img src="$id.plaw_pass${t}.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass${t}.extractOutliers.png"><img src="$id.spline_pass${t}.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparison_pass${t}.png"><img src="$id.comparison_pass${t}.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.plaw_pass${t}.qplot.png"><img src="$id.plaw_pass${t}.qplot.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.spline_pass${t}.qplot.png"><img src="$id.spline_pass${t}.qplot.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonDisc_pass${t}.png"><img src="$id.comparisonDisc_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonFitDisc_pass${t}.png"><img src="$id.comparisonFitDisc_pass${t}.png"  width=400> </a></td>' >> $html; \
			done

		sys echo '<tr>' >> $html
		sys echo '</tbody></table>' >> $html
		sys echo '</body></html>' >> $html
	}
}


void _hic_step6a( string before_after, string id, \
		string list_contacts_bfr_ice, string list_contacts_aft_ice_biases, string contacts_per_frag, int w, string out_dir, string info ) {
	//#  - perform fit-hi-c on data before and after ICE
	//#  - places results into $PROJDIR/data/fit-hi-c-results
	prefix 		:= "$out_dir/$id"

	distLowThres := w*5000 //$(($w*5000))

	log := "$prefix"+"_log.conf.file"
	html := "$prefix"+"_fithic.html"

	in 	:= [list_contacts_bfr_ice, list_contacts_aft_ice_biases, contacts_per_frag]
	out 	:= [log, html]

	task( taskName := "hic6a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys discBinsize=$(($(($dist_up_thres-$distLowThres))/$no_of_bins))
		sys echo ${discBinsize}

		sys date >> $log
		sys echo w=$w no_of_bins=$no_of_bins mapp_thres_hic6=$mapp_thres_hic6 no_of_passes=$no_of_passes dist_up_thres=$dist_up_thres distLowThres=$distLowThres discBinsize=${discBinsize} residual_factor=$residual_factor>> $log 
		sys echo >> $log

		sys echo '<html>' > $html
		sys echo '<head><meta http-equiv= "content-type" content="text/html; charset=UTF-8"><title></title></head>' >> $html
		sys echo '<body>' >> $html
		sys echo '<table  border="1" >' >> $html
		sys echo '<tbody>' >> $html

		sys echo '<tr>' >> $html
		sys echo '<th scope="col"> Library label </th>' >> $html

		sys for t in `seq $(($no_of_passes+1))`; do \
			#echo '<th scope="col"> Equal occupancy binning </th>' >> $html; \
			echo '<th scope="col"> Fitting - power-law </th>' >> $html; \
			echo '<th scope="col"> Fitting - spline </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - power-law </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - spline </th>' >> $html; \
			echo '<th scope="col"> FDR - compare all </th>' >> $html; \
			echo '<th scope="col"> FDR - spline </th>' >> $html; \
			echo '<th scope="col"> Binning bias </th>' >> $html; \
			done

		sys echo '</tr>' >> $html

		sys noOfCols=$((($no_of_passes+1)*7))
		sys echo '<tr>' >> $html
		sys echo '<th> </th>' >> $html
		sys for t in `seq ${noOfCols}`; do \
			echo '<th> ${t} </th>' >> $html; \
			done
		sys echo '</tr>' >> $html

		sys if [[ $before_after == "afterICE" ]]; then \
			python $(which fit-hic-LATEST_std.py) -l "$id" -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out; \
			else \
			python $(which fit-hic-LATEST_std.py) -l "$id" -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $mapp_thres_hic6 -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out; \
			fi

		sys echo '<tr>' >> $html
		sys echo '<td> $id </td>' >> $html
		sys for t in `seq $(($no_of_passes+1))`; do \
			echo '<td> <a href="$id.plaw_pass${t}.png"><img src="$id.plaw_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass${t}.png"><img src="$id.spline_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.plaw_pass${t}.extractOutliers.png"><img src="$id.plaw_pass${t}.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass${t}.extractOutliers.png"><img src="$id.spline_pass${t}.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparison_pass${t}.png"><img src="$id.comparison_pass${t}.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.plaw_pass${t}.qplot.png"><img src="$id.plaw_pass${t}.qplot.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.spline_pass${t}.qplot.png"><img src="$id.spline_pass${t}.qplot.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonDisc_pass${t}.png"><img src="$id.comparisonDisc_pass${t}.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonFitDisc_pass${t}.png"><img src="$id.comparisonFitDisc_pass${t}.png"  width=400> </a></td>' >> $html; \
			done

		sys echo '<tr>' >> $html
		sys echo '</tbody></table>' >> $html
		sys echo '</body></html>' >> $html
	}
}

string get_cln_pair( int lib, int rep ) {

	key := "cln_pair" + lib + "_" + rep
	key2 := "cln_pair_L" + lib + "_R" + rep
	key3 := "cln_pair_R" + rep + "_L" + lib

	if ( cmd_line_arg_has_key( key ) ) {
		return get_cmd_line_arg_val( key )
	}
	else if ( cmd_line_arg_has_key( key2 ) ) {
		return get_cmd_line_arg_val( key2 )
	}	
	else if ( cmd_line_arg_has_key( key3 ) ) {
		return get_cmd_line_arg_val( key3 )
	}	
	else if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( conf.hasKey( key3 ) ) {
		return get_path( conf{ key3 } )
	}
	return ""
}

string get_id( int lib, int rep ) {

	return "$prefix"+"_"+lib_names[lib-1]+"_"+rep_names[rep-1]
}

string get_id( int lib ) {

	return "$prefix"+"_"+lib_names[lib-1]
}

string get_merge_method() {

	if ( merge == 0 ) {
		return "no_merge"
	}
	else if ( merge == 1 ) {
		return "reps_merged"
	}
	else if ( merge == 2 ) {
		return "all_merged"		
	}
}

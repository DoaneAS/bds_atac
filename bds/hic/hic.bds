#!/usr/bin/env bds

include "hic_base.bds"


help HiC settings (mapped data)
help   There are two ways to define paths for mapped data (cleaned pairs)
help   1) Using Root directory of mapped data
root_mapped 		:= ""		help Root path for mapped data ('out_dir' of hic_map.bds) (default: blank).

help   2) Using paths for individual cleaned pairs
help      Cleaned pair paths
help         -cln_pair[Library_ID]_[Replicate_ID] [CLEANED_PAIR_FILE_PATH]
help         or
help         -cln_pair_L[Library_ID]_R[Replicate_ID] [CLEANED_PAIR_FILE_PATH]

help HiC settings (analysis method, merge method and resolution)
method 			:= "re"		help Analysis method (re: using RE Windows, fixed: using Fixed Windows, default: re).
merge 			:= 1 		help Method for merging replicates and libraries (0: no merge, 1: merge reps only, 2: merge reps and libs, default: 1).
res 			:= ""		help Resolution, comma separated integers â€“ Number of consecutive RE sites for RE windows, eg. '5,10,100', or bases for fixed windows, eg. '100000, 500000, 1000000'.

help HiC settings (step 1)
RE_file 		:= "" 		help Bed file with restriction enzyme cut sites.

help HiC settings (step 2 and 3)
blacklist 		:= ""		help Blacklist file path.
read_len 		:= 0 		help Read Length.
intra_chr_thres_mltpl 	:= 0		help Intra-Chromosomal Threshold Multiplier, integer (x resolution) - A multiplication parameter, when multiplied by resolution, defines a lower bound on mid-range distances. The rule of thumb here is to avoid distances lower than a resolution window or lower than an average meta-fragment length. When 10 consecutive RE fragments are used per meta-fragment use at least 5000 (10x5000=50000bp). When fixed-sizes windows are used, use at least 1 (length of 1 fixed-size window). In order to have no lower bound simply set this argument to 0 (default: 5000 for meta-fragments or 1 for fixed-size windows).
mem_hic2 		:= "20G"	help Max. memory for hic step2 (default: 20G).
wt_hic2			:= "40h"	help Walltime for hic step2 (default: 40h, 40:00:00).

help HiC settings (step 4)
mapp_thres  		:= "0.5"	help Mappability, float - Filters out loci that are less mappable than the threshold (default: 0.5).
mem_hic4 		:= "20G"	help Max. memory for hic step4 (default: 20G).
wt_hic4			:= "70h"	help Walltime for hic step4 (default: 70h, 70:00:00).

help HiC settings (step 6)
no_of_bins		:= 0		help Number of equal-occupancy (count) bins (default: 200 for method 're' and 100 for method 'fixed' ).
dist_up_thres 		:= 10000000	help Upper bound on the intra-chromosomal distance range (default: 10000000).
dist_low_thres_mltpl 	:= 0		help Lower Bound Multiplier, integer (x resolution). A multiplication parameter, when multiplied by resolution, defines a lower bound on the intra-chromosomal distance range (default: 5000 for meta-fragments or 2 for fixed-size windows).
fit_mapp		:= 1 		help Minimum number of hits per locus that has to exist to call it mappable. (default: 1).
no_of_passes 		:= 1 		help Number of passes after the initial (before) fit. (default: 1) (after).
residual_factor 	:= -1 		help How many times better residual is desired for splines compared to power-law fit. (default: -1).
org 			:= "human" 	help org (default: human).
ref 			:= "hg19"	help ref (default: hg19).
re 			:= "HindIII" 	help re (default: hindIII).


int[] resolution

// ugly global variables (key==w (resolution))

string{} mid_points // mid points

string{} RE_sites // RE sites (for method 'RE')
string{} binned_blacklists // binned blacklists (for method 'fixed')

string{} biases // biases
string{} clean_pairs_comb // merged and combined clean pairs


help()

init_hic()

find_mapped_data()

set_shell_env()

merge_cleaned_pairs()

hic()



void init_hic() {

	if ( conf_file_exists() ) {

		root_mapped 		= get_conf_val( root_mapped, 		["root_mapped"] )
		method 			= get_conf_val( method, 		["method"] ) 
		merge 			= get_conf_val_int( merge, 		["merge"] )
		res 			= get_conf_val( res, 			["res"] ) 
		RE_file 		= get_conf_val( RE_file, 		["RE_file","REfile"] )
		blacklist 		= get_conf_val( blacklist, 		["blacklist"] ) 
		read_len 		= get_conf_val_int( read_len, 		["read_len", "read_length", "readlen", "readlength"] )
		intra_chr_thres_mltpl	= get_conf_val_int( intra_chr_thres_mltpl,	["intra_chr_thres_mltpl"] )
		mapp_thres  		= get_conf_val( mapp_thres, 		["mapp_thres", "mapp_thres_hic4"] ) 
		no_of_bins		= get_conf_val_int( no_of_bins, 	["no_of_bins", "num_bin", "no_bin"] )
		dist_up_thres 		= get_conf_val_int( dist_up_thres, 	["dist_up_thres"] )
		dist_low_thres_mltpl 	= get_conf_val_int( dist_low_thres_mltpl,	["dist_low_thres_mltpl"] )
		
		fit_mapp		= get_conf_val_int( fit_mapp, 		["fit_mapp"] )
		no_of_passes 		= get_conf_val_int( no_of_passes, 	["no_of_passes"] )
		residual_factor 	= get_conf_val_int( residual_factor, 	["residual_factor"] )

		org 			= get_conf_val( org, 			["org"] )
		ref 			= get_conf_val( ref, 			["ref"] )
		re 			= get_conf_val( re, 			["re"] ) 

		wt_hic2 		= get_conf_val( wt_hic2, 		["walltime_hic2", "wt_hic2", "timeout_hic2"] )
		wt_hic4 		= get_conf_val( wt_hic4, 		["walltime_hic4", "wt_hic4", "timeout_hic4"] )

		mem_hic2 		= get_conf_val( mem_hic2, 		["memory_hic2","mem_hic2"] )
		mem_hic4 		= get_conf_val( mem_hic4, 		["memory_hic4","mem_hic4"] )

	}
	
	if ( !is_method_RE() && !is_method_fixed() ) error("Method (-method []) must be 're' or 'fixed'! \n\n")
	
	if ( is_method_RE() ) { // set default values for multipliers
		if ( intra_chr_thres_mltpl == 0 ) 	intra_chr_thres_mltpl = 5000
		if ( dist_low_thres_mltpl == 0 ) 	dist_low_thres_mltpl  = 5000
		if ( no_of_bins == 0 ) 			no_of_bins 	      = 200
	}
	else {
		if ( intra_chr_thres_mltpl == 0 ) 	intra_chr_thres_mltpl = 1
		if ( dist_low_thres_mltpl == 0 ) 	dist_low_thres_mltpl  = 2
		if ( no_of_bins == 0 ) 			no_of_bins 	      = 100
	}

	if ( res == "" ) {
		error("Define resolution array with '-res [COMMA_SEPARATED_INTEGERS]'. Example: '-res 10,100,200'\n\n")
	}
	else {
		// create resolution array
		_resolution := res.trim().replace(";",",").replace(":",",").split(",")

		for ( string w : _resolution ) {
			resolution.add( w.parseInt() )
		}
	}

	if ( read_len == 0 ) error("Define read length (with -read_len [])! \n\n") // 50

	if ( is_method_RE() && !path_exists( RE_file ) ) error("\nRE file doesn't exists! ($RE_file) \n")	

	if ( is_method_fixed() && !path_exists( chrsz ) ) error("\nChrome sizes file doesn't exists! ($chrsz) \n")	

	if ( !path_exists( blacklist ) ) error("\nBlacklist file doesn't exists! ($blacklist)\n")	

	if ( umap_hic != "" ) umap = umap_hic

	if ( !path_exists( umap) ) error("\nUmap or umap_hic directory doesn't exists! (umap: $umap, umap_hic: $umap_hic)\n")

	if ( v ) { // verbose
		print("\n")
		print( "Root for mapped data\t: $root_mapped\n" )
		print( "Merge method\t\t: $merge ( " + get_merge_name() + " )\n" )
		print( "Resolution\t\t: $res\n" )
		print( "RE file\t\t\t: $RE_file\n" )
		print( "Blacklist\t\t: $blacklist\n" )
		print( "Read Length\t\t: $read_len\n" )
		print( "Intra chr. threshold multiplier\t: $intra_chr_thres_mltpl\n" )
		print( "Mappability threshold\t\t: $mapp_thres\n" )
		print( "Number of bins\t\t\t: $no_of_bins\n" )
		print( "Dist. up threshold\t\t: $dist_up_thres\n" )
		print( "Dist. low threshold multiplier\t: $dist_low_thres_mltpl\n" )
		print( "Fit. mappability threshold\t: $fit_mapp\n" )
		print( "Number of passes\t\t: $no_of_passes\n" )
		print( "Residual factor\t\t\t: $residual_factor\n" )
		print( "org\t\t\t\t: $org\n" )
		print( "ref\t\t\t\t: $ref\n" )
		print( "re\t\t\t\t: $re\n" )
		print( "Walltime for hic step2\t\t: $wt_hic2\n")
		print( "Walltime for hic step4\t\t: $wt_hic4\n")
		print( "Max. memory (hic step2)\t\t: $mem_hic2\n" )
		print( "Max. memory (hic step4)\t\t: $mem_hic4\n" )
		print( "Umap dir.\t\t\t: $umap\n")
	}
}

void find_mapped_data() {

	if ( root_mapped != "" ) {
		print("\n\nReading cleaned pairs from root of mapped directory...\n\n")
	}
	else {
		print("\n\nReading cleaned pairs from command line or configuration file...\n\n")
	}

	for (int lib=1; lib<=num_lib; lib++) {
		for (int rep=1; rep<=num_rep; rep++) {

			id := get_id( lib, rep )

			string cleaned

			if ( root_mapped != "" ) {
				cleaned = "$root_mapped/cleanedPairs/$id/$id"+"_cleanedPairs.gz"
			}
			else {
				cleaned = get_cln_pair( lib, rep )
			}

			print("\t$id: $cleaned\n")
			if ( !path_exists( cleaned ) ) error("\t\tFile doesn't exists!\n")

			cleaned_pairs{ id } 	= cleaned
		}
	}
}

void merge_cleaned_pairs() {  // return: key=id, val=comma-separated cleanedPairs files

	if ( merge == 0 ) { // no merge

		clean_pairs_comb = cleaned_pairs
	}
	else if ( merge == 1 ) { // merge rep only

		for (int lib=1;lib<=num_lib;lib++) {

			new_id := get_id( lib )

			for (int rep=1;rep<=num_rep;rep++) {

				id := get_id( lib, rep )

				if ( clean_pairs_comb.hasKey( new_id ) ) \
					clean_pairs_comb{ new_id } = clean_pairs_comb{ new_id } + "," + cleaned_pairs{ id }
				else \
					clean_pairs_comb{ new_id } = cleaned_pairs{ id }
			}
		}
	}
	else if ( merge == 2 ) { // merge rep and lib

		new_id := prefix

		for (int lib=1;lib<=num_lib;lib++) {

			for (int rep=1;rep<=num_rep;rep++) {

				id := get_id( lib, rep )

				if ( clean_pairs_comb.hasKey( new_id ) ) \
					clean_pairs_comb{ new_id } = clean_pairs_comb{ new_id } + "," + cleaned_pairs{ id }
				else \
					clean_pairs_comb{ new_id } = cleaned_pairs{ id }
			}
		}
	}

	print("\nMerge method: "+get_merge_name()+"\n")

	print("\nMerged cleaned pairs:\n\n")

	for( string id : clean_pairs_comb.keys() ) {
		print("\t$id: "+clean_pairs_comb{ id }+"\n")
	}
}

void hic() {

	for ( int w : resolution ) {

		if ( no_par_job )   _hic( w )
		else 		par _hic( w )
	}
}

void _hic( int w ) {

	// HiC_preprocess first (step 1, 1a and 3)
	_hic_preprocess( w )

	wait

	// HiC_postprocess (step 2, 2a, 4, 5, 6, 6a)
	for( string id : clean_pairs_comb.keys() ) {

		if ( no_par_job )    _hic_postprocess( id, clean_pairs_comb{ id }, w )
		else 		 par _hic_postprocess( id, clean_pairs_comb{ id }, w )
	}

	if ( no_par_job ) wait
}

void _hic_preprocess( int w ) {

	info := get_res_prefix()+"$w"

	// create output dir
	bias_dir 	:= mkdir_path( "$out_dir/preprocessedForBias" )

	if ( is_method_RE() ) {

		RE_site_dir 	:= mkdir_path( "$out_dir/RESites" )

		( RE_sites{"$w"}, mid_points{"$w"} ) = _hic_step1( w, RE_site_dir, info )
		wait

		biases{"$w"} = _hic_step3( RE_sites{"$w"}, w, bias_dir, info )
	}
	else {
		mid_point_dir 	:= mkdir_path( "$out_dir/FixedWindowsMidpoints")
		blacklist_dir	:= mkdir_path( "$out_dir/Blacklist")

		mid_points{"$w"} = _hic_step1_fixed_win( w, mid_point_dir, info )
		if ( no_par_job ) wait

		binned_blacklists{"$w"} = _hic_step1a_fixed_win( w, blacklist_dir, info )
		if ( no_par_job ) wait

		biases{"$w"} = _hic_step3_fixed_win( w, bias_dir, info )	
	}
}

void _hic_postprocess( string id, string clean_pairs_comb, int w ) {

	RE 	:= get_res_prefix()
	info 	:= "$RE$w $id"

	// create output dirs
	bfr_ice_dir	:= mkdir_path( "$out_dir/interactionCounts/beforeICE/$RE$w")
	raw_contact_dir := mkdir_path( "$out_dir/Plots")
	aft_ice_dir	:= mkdir_path( "$out_dir/interactionCounts/afterICE/$RE$w")
	plot_dir	:= mkdir_path( "$out_dir/Plots/bias/$RE$w")
	contact_dir	:= mkdir_path( "$out_dir/ContactsPerFragment/$RE$w")
	
	hic_bfr_ice_dir := mkdir_path( "$out_dir/fit-hi-c-results/$RE$w/beforeICE/$id")
	hic_aft_ice_dir := mkdir_path( "$out_dir/fit-hi-c-results/$RE$w/afterICE/$id")

	hic_bfr_ice_std_dir := mkdir_path( "$out_dir/fit-hi-c-results_std/$RE$w/beforeICE/$id")
	hic_aft_ice_std_dir := mkdir_path( "$out_dir/fit-hi-c-results_std/$RE$w/afterICE/$id")

	// parse clean_pairs_comb (comma separated cleanedPairs files)
	cleaned := clean_pairs_comb.split(",")

	string list_contacts_bfr_ice

	if ( is_method_RE() ) {
		list_contacts_bfr_ice 	= _hic_step2( id, cleaned, RE_sites{"$w"}, w, bfr_ice_dir, info )
	}
	else {
		list_contacts_bfr_ice 	= _hic_step2_fixed_win( id, cleaned, binned_blacklists{"$w"}, w, bfr_ice_dir, info )	
	}

	wait

	raw_contact_cnts 		:= _hic_step2a( id, list_contacts_bfr_ice, w, raw_contact_dir, info )	

	if ( no_par_job ) wait

	list_contacts_aft_ice_biases 	:= _hic_step4( id, list_contacts_bfr_ice, biases{"$w"}, aft_ice_dir, info )

	if ( no_par_job ) wait

	contacts_per_frag 		:= _hic_step5( id, list_contacts_bfr_ice, mid_points{"$w"}, contact_dir, info )

	wait

	dist_bias 			:= _hic_step4a( id, list_contacts_aft_ice_biases, w, plot_dir, info )

	if ( no_par_job ) wait

	_hic_step6( "beforeICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_bfr_ice_dir, info )

	if ( no_par_job ) wait

	_hic_step6( "afterICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_aft_ice_dir, info )

	if ( no_par_job ) wait

	_hic_step6a( "beforeICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_bfr_ice_std_dir, info )

	if ( no_par_job ) wait

	_hic_step6a( "afterICE", id, list_contacts_bfr_ice, list_contacts_aft_ice_biases, \
			contacts_per_frag, w, hic_aft_ice_std_dir, info )
}

string _hic_step1( int w, string out_dir, string info ) {
	//# write out file with RE fragments @ RE-resolution

	RE 		:= get_res_prefix()

	RE_site 	:= "$out_dir/REFrags.$RE$w"
	RE_site_mid 	:= "$out_dir/REFragsMid.$RE$w"

	in 	:= [RE_file]
	out 	:= [RE_site, RE_site_mid]

	task( taskName := "hic1 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys python $(which get-contactCounts-atRESize.py) $RE_file $w $RE_site $RE_site_mid
	}

	return out	
}

string _hic_step1_fixed_win( int w, string out_dir, string info ) {

	RE 	  := get_res_prefix()
	mid_point := "$out_dir/$org-$ref.$RE$w"

	out 	  := mid_point

	task( taskName := "hic1_fixwin $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		!path_exists( out ) ) {

		sys $SHCMD_INIT	

		sys python $(which generate_binned_midpoints.py) $w <(grep -P -v '_|chrM' $chrsz) $mid_point
	}

	return out
}

string _hic_step1a_fixed_win( int w, string out_dir, string info ) {

	RE 	  := get_res_prefix()
	binned_blacklist := "$out_dir/BlackList.$RE$w"

	out := binned_blacklist

	task( taskName := "hic1_fixwin $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		!path_exists( out ) ) {

		sys $SHCMD_INIT	

		sys python $(which generate_binned_blacklist.py) $w $blacklist $binned_blacklist
	}

	return out	
}

string _hic_step2( string id, string[] cleaned_pairs, string RE_site, int w, string out_dir, string info ) {
	//# step 2 operations:
	//#  - get contacts at fixed window size 
	prefix := "$out_dir/$id"

	cleaned_tmp 	:= prefix+"_cleanedPairs.tmp"

	//IntrachrThres := w*5000 //$(($w*5000)) # distance threshold for calculating intrachromosomal interactions
	IntrachrThres 	:= w*intra_chr_thres_mltpl //$(($w*5000)) # distance threshold for calculating intrachromosomal interactions

	IntSite1Temp := prefix+"_IntSite1Temp"
	IntSite2Temp := prefix+"_IntSite2Temp"
	Site1NoBlack := prefix+"_Site1NoBlack"
	Site2NoBlack := prefix+"_Site2NoBlack"
	Read1 := prefix+"_Read1"
	Read2 := prefix+"_Read2"

	list_contacts_bfr_ice 	:= prefix+"_ListOfContacts"
	list_contacts_bfr_ice_gz:= prefix+"_ListOfContacts.gz"

	in  	:= [RE_site];	for ( string file : cleaned_pairs ) in.add( file )
	out 	:= list_contacts_bfr_ice_gz

	cleaned_pairs_all := array_to_str( cleaned_pairs, " " )

	task( taskName := "hic2 $info", cpus := nth, timeout := parse_time(wt_hic2), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//# remove pairs separated closer than threshold, remove chrM
		//sys zcat $cleaned_pairs_all \
		//	| awk 'length($3)<=5 && length($7)<=5 {print}' | grep -v chrM \
		//	| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print $3,$4,$4+$read_len,$1}' t=$IntrachrThres \
		//	| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite1Temp
		//sys zcat $cleaned_pairs_all \
		//	| awk 'length($3)<=5 && length($7)<=5 {print}' | grep -v chrM \
		//	| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print $7, $8, $8+$read_len, $1}' t=$IntrachrThres \
		//	| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite2Temp

		sys zcat $cleaned_pairs_all \
			| grep -v chrM | awk 'length($3)<=5 && length($7)<=5 {print}' \
			| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print}' t=$IntrachrThres > $cleaned_tmp
		sys cat $cleaned_tmp | awk '{print $3,$4,$4+$read_len,$1}' \
			| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite1Temp
		sys cat $cleaned_tmp | awk '{print $7,$8,$8+$read_len,$1}' \
			| /usr/bin/perl -p -i -e 's/ /\t/g' > $IntSite2Temp
		sys rm -f $cleaned_tmp

		//# remove reads that overlap with Black list 
		sys bedtools intersect -v -a $IntSite1Temp -b $blacklist > $Site1NoBlack
		sys bedtools intersect -v -a $IntSite2Temp -b $blacklist > $Site2NoBlack

		//# assign reads to RE fragments
		sys bedtools intersect -wao -a $Site1NoBlack -b $RE_site \
			| awk '{print  $1, $8, $4}'| sort -k3,3| uniq -f 2 \
			| awk '{print  $3, $1, $2}'| sort -k1,1 > $Read1

		sys bedtools intersect -wao -a $Site2NoBlack -b $RE_site \
			| awk '{print  $1, $8, $4}'| sort -k3,3| uniq -f 2 \
			| awk '{print  $3, $1, $2}'| sort -k1,1 > $Read2

		//# join two fragment reads and calculate unique pairs
		sys join $Read1 $Read2 \
			| awk '{if($2<$4 || ($2==$4 && $3<=$5)) print $2,$3,$4,$5; else print $4,$5,$2, $3}' \
			| sort | uniq -c \
			| awk 'OFS="\t"{print $2,$3,$4,$5,$1}' > $list_contacts_bfr_ice

		sys gzip -f $list_contacts_bfr_ice
		sys rm -f $IntSite1Temp $IntSite2Temp $Site1NoBlack $Site2NoBlack $Read1 $Read2
	}

	return out
}


string _hic_step2_fixed_win( string id, string[] cleaned_pairs, string binned_blacklist, int w, string out_dir, string info ) {
	//# step 2 operations:
	//#  - get contacts at fixed window size 
	prefix := "$out_dir/$id"

	IntrachrThres 	:= w*intra_chr_thres_mltpl //$(($w*1))

	list_contacts_bfr_ice 	:= prefix+"_ListOfContacts"
	list_contacts_bfr_ice_gz:= prefix+"_ListOfContacts.gz"

	list_contacts_bfr_ice_black 	:= prefix+"_ListOfContacts_withBlackList"
	list_contacts_bfr_ice_black_gz	:= prefix+"_ListOfContacts_withBlackList.gz"

	in  	:= [binned_blacklist];	for ( string file : cleaned_pairs ) in.add( file )
	out 	:= list_contacts_bfr_ice_gz

	cleaned_pairs_all := array_to_str( cleaned_pairs, " " )

	task( taskName := "hic2_fixwin $info", cpus := nth, timeout := parse_time(wt_hic2), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

	        sys zcat $cleaned_pairs_all \
	        	| awk 'length($3)<=5 && length($7)<=5 {print}' | grep -v chrM \
	        	| awk '$3!=$7 || ($3==$7 && ($4-$8> t || $8-$4> t)) {print}' t=$IntrachrThres \
	        	| awk '{print $3,int($4/r)*r,$7,int($8/r)*r}' r=$w \
	        	| awk '{if($1<$3 || ($1==$3 && $2<=$4)) print $1,$2,$3,$4; else print $3,$4,$1,$2}' | sort | uniq -c \
	        	| awk 'OFS="\t"{print $2,$3+r/2,$4,$5+r/2,$1}' r=$w > $list_contacts_bfr_ice_black
	        //#remove black list contacts
	        sys python $(which Remove-Blacklist-Bins.py) $w $list_contacts_bfr_ice_black $binned_blacklist $list_contacts_bfr_ice $id
	        sys gzip -f $list_contacts_bfr_ice $list_contacts_bfr_ice_black
	}

	return out
}

string _hic_step2a( string id, string list_contacts_bfr_ice, int w, string out_dir, string info ) {
	
	RE 	:= get_res_prefix()
	prefix 	:= "$out_dir/$id"
	raw_contact_cnts 	:= "$prefix"+"_RawContactCounts_$RE$w"
	raw_contact_cnts_png 	:= "$prefix"+"_RawContactCounts_$RE$w.png"

	in 	:= list_contacts_bfr_ice
	out 	:= raw_contact_cnts_png

	task( taskName := "hic2a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT

		sys python $(which plot_ScatterContactCounts.py) $list_contacts_bfr_ice $id $w $raw_contact_cnts
		sys rm -f $raw_contact_cnts
	}

	return out
}

string _hic_step3( string RE_site, int w, string out_dir, string info ) {
	//# preprocess the genome to get mappability per window. Note: needs to be run only once for a particular resolution

        bias 	:= "$out_dir/$org-$ref.$re."+get_res_prefix()+"$w"

        in 	:= RE_site
        out 	:= bias

	task( taskName := "hic3 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys python $(which mappability_from_bed.py) --regions $RE_site --read_length $read_len --out $bias --map_prefix $umap"/chr"
	}

	return out
}

string _hic_step3_fixed_win( int w, string out_dir, string info ) {
	//# preprocess the genome to get mappability per window. Note: needs to be run only once for a particular resolution

	RE 	:= get_res_prefix()

	window_file 	:= "$out_dir/$org-$ref.$re.$RE$w"+"_windowFile.bed"
        bias 	:= "$out_dir/$org-$ref.$re.$RE$w"

        out 	:= bias

	task( taskName := "hic3_fixwin $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		!path_exists( out ) ) {

		sys $SHCMD_INIT	

		sys bedtools makewindows -i winnum -w $w -g <(grep -P -v '_|chrM' $chrsz) | awk '{wend=$4*$w}{print $1"\t"$2"\t"wend}' > $window_file
		//#intersect to count REs
		sys cat $window_file | sort -k1,1 -k2,2n > "$window_file"_withNumREsites.bed

		//##run mappability on the bed-like file
		sys python $(which mappability_from_bed.py) --regions "$window_file"_withNumREsites.bed --read_length $read_len --out $bias --map_prefix $umap"/chr"
		sys rm -f $window_file "$window_file"_withNumREsites.bed
		//# Output will look like ${biasdir}/human-hg19.HindIII.w40000
	}

	return out
}

string _hic_step4( string id, string list_contacts_bfr_ice, string bias, string out_dir, string info ) {
	//# step 4 operations:
	//#  - normalizes each library using sparse ICE implementation
	//#  - calculate biases for each window.

	prefix 	:= "$out_dir/$id"

	list_contacts_aft_ice 	:= "$prefix"+"_ListOfContacts_after_ICE"

	list_contacts_aft_ice_biases 	:= "$list_contacts_aft_ice.biases"
	list_contacts_aft_ice_biases_gz := "$list_contacts_aft_ice.biases.gz"

	in 	:= [list_contacts_bfr_ice, bias]
	out 	:= list_contacts_aft_ice_biases_gz

	//#additional variables: 
	norm := "l1" // # l1 or l2 norm

	task( taskName := "hic4 $info", cpus := nth, timeout := parse_time(wt_hic4), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys zcat $list_contacts_bfr_ice > $list_contacts_bfr_ice.temp
		sys cat $bias  > $bias.temp
		sys python $(which ICE-with-sparseMatrix.py) $list_contacts_bfr_ice.temp $bias.temp $norm $list_contacts_aft_ice $mapp_thres
		sys gzip -f $list_contacts_aft_ice $list_contacts_aft_ice_biases
		sys rm -rf $list_contacts_bfr_ice.temp $bias.temp
	}

	return out
}

string _hic_step4a( string id, string list_contacts_aft_ice_biases, int w, string out_dir, string info ) {

	prefix 		:= "$out_dir/$id"
	dist_bias 	:= "$prefix"+"_DistOfBiases"
	dist_bias_png 	:= "$prefix"+"_DistOfBiases.png"

	in 	:= list_contacts_aft_ice_biases
	out 	:= dist_bias_png

	task( taskName := "hic4a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//sys echo $lib $ref $org $re		
		sys python $(which plot_DistOfBiases.py) $list_contacts_aft_ice_biases $dist_bias $id $w
	}

	return out
}

string _hic_step5( string id, string list_contacts_bfr_ice, string mid_point, string out_dir, string info ) {
	//#  - calculate total numbmer of contacts coming out of each window.

	prefix 		:= "$out_dir/$id"

	contacts_per_frag 	:= "$prefix"+"_ContactsPerFragment"
	contacts_per_frag_gz 	:= "$prefix"+"_ContactsPerFragment.gz"
	srt_contacts 		:= "$prefix"+"_SortedContacts"

	in 	:= [list_contacts_bfr_ice, mid_point]
	out 	:= contacts_per_frag_gz

	task( taskName := "hic5 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		sys touch $contacts_per_frag.tmp
		sys zcat $list_contacts_bfr_ice | awk '{print $1, $2, $5}' > $contacts_per_frag.tmp
		sys zcat $list_contacts_bfr_ice | awk '{print $3, $4, $5}' >> $contacts_per_frag.tmp
		//sys sort -k 1,1 $tmp > $SortedContacts
		sys sort -k1,1 -k2n,2 $contacts_per_frag.tmp > $srt_contacts
		sys echo >> $srt_contacts
		sys cat $srt_contacts | gawk '($1==key1 && $2==key2) { sum+=$3} ($1 != key1 || $2 != key2) {if (NR>1){print key1, key2, sum} key1=$1; key2=$2; sum=$3}' > $contacts_per_frag.tmp
		sys python $(which MergeCounts.py) $mid_point $contacts_per_frag.tmp $contacts_per_frag
		sys gzip -f $contacts_per_frag
		sys rm -f $contacts_per_frag.tmp $srt_contacts
	}
	return out
}

void _hic_step6( string before_after, string id, \
		string list_contacts_bfr_ice, string list_contacts_aft_ice_biases, string contacts_per_frag, int w, string out_dir, string info ) {
	//#  - perform fit-hi-c on data before and after ICE
	//#  - places results into $PROJDIR/data/fit-hi-c-results
	prefix 		:= "$out_dir/$id"

	//distLowThres := w*5000 //$(($w*5000))
	distLowThres := w*dist_low_thres_mltpl //$(($w*5000))

	disc_bin_size := is_method_RE() ? "\$((\$(($dist_up_thres-$distLowThres))/$no_of_bins))" : "$w"

	log := "$prefix"+"_log.conf.file"
	html := "$prefix"+"_fithic.html"

	in 	:= [list_contacts_bfr_ice, list_contacts_aft_ice_biases, contacts_per_frag]
	out 	:= [log, html]

	task( taskName := "hic6 $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//sys discBinsize=$(($(($dist_up_thres-$distLowThres))/$no_of_bins))
		sys discBinsize=$disc_bin_size
		sys echo ${discBinsize}

		sys date >> $log
		sys echo w=$w no_of_bins=$no_of_bins fit_mapp=$fit_mapp no_of_passes=$no_of_passes dist_up_thres=$dist_up_thres distLowThres=$distLowThres discBinsize=${discBinsize} residual_factor=$residual_factor>> $log 
		sys echo >> $log

		sys echo '<html>' > $html
		sys echo '<head><meta http-equiv= "content-type" content="text/html; charset=UTF-8"><title></title></head>' >> $html
		sys echo '<body>' >> $html
		sys echo '<table  border="1" >' >> $html
		sys echo '<tbody>' >> $html

		sys echo '<tr>' >> $html
		sys echo '<th scope="col"> Library label </th>' >> $html

		sys for t in `seq $(($no_of_passes+1))`; do \
			#echo '<th scope="col"> Equal occupancy binning </th>' >> $html; \
			echo '<th scope="col"> Fitting - power-law </th>' >> $html; \
			echo '<th scope="col"> Fitting - spline </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - power-law </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - spline </th>' >> $html; \
			echo '<th scope="col"> FDR - compare all </th>' >> $html; \
			echo '<th scope="col"> FDR - spline </th>' >> $html; \
			echo '<th scope="col"> Binning bias </th>' >> $html; \
			done

		sys echo '</tr>' >> $html

		sys noOfCols=$((($no_of_passes+1)*7))
		sys echo '<tr>' >> $html
		sys echo '<th> </th>' >> $html
		sys for t in `seq ${noOfCols}`; do \
			echo '<th> '${t}' </th>' >> $html; \
			done
		sys echo '</tr>' >> $html

		sys if [[ $before_after == "afterICE" ]]; then \
			# REMOVED -d and -r and comparisonMode \
			python $(which fit-hic-LATEST.py) -l $id -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out \
	  		#python $(which fit-hi-c.py) -l $id -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes  -o $out_dir  > $out_dir/$id.out; \
			else \
			python $(which fit-hic-LATEST.py) -l $id -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out \
	  		#python $(which fit-hi-c.py) -l $id -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes  -o $out_dir > $out_dir/$id.out; \
			fi

		sys echo '<tr>' >> $html
		sys echo '<td> $id </td>' >> $html
		sys for t in `seq $(($no_of_passes+1))`; do \
			echo '<td> <a href="$id.plaw_pass'${t}'.png"><img src="$id.plaw_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass'${t}'.png"><img src="$id.spline_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.plaw_pass'${t}'.extractOutliers.png"><img src="$id.plaw_pass'${t}'.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass'${t}'.extractOutliers.png"><img src="$id.spline_pass'${t}'.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparison_pass'${t}'.png"><img src="$id.comparison_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.plaw_pass'${t}'.qplot.png"><img src="$id.plaw_pass'${t}'.qplot.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.spline_pass'${t}'.qplot.png"><img src="$id.spline_pass'${t}'.qplot.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonDisc_pass'${t}'.png"><img src="$id.comparisonDisc_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonFitDisc_pass'${t}'.png"><img src="$id.comparisonFitDisc_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			done

		sys echo '<tr>' >> $html
		sys echo '</tbody></table>' >> $html
		sys echo '</body></html>' >> $html
	}
}


void _hic_step6a( string before_after, string id, \
		string list_contacts_bfr_ice, string list_contacts_aft_ice_biases, string contacts_per_frag, int w, string out_dir, string info ) {
	//#  - perform fit-hi-c on data before and after ICE
	//#  - places results into $PROJDIR/data/fit-hi-c-results
	prefix 		:= "$out_dir/$id"

	//distLowThres := w*5000 //$(($w*5000))
	distLowThres := w*dist_low_thres_mltpl //$(($w*5000))

	disc_bin_size := is_method_RE() ? "\$((\$(($dist_up_thres-$distLowThres))/$no_of_bins))" : "$w"

	log := "$prefix"+"_log.conf.file"
	html := "$prefix"+"_fithic.html"

	in 	:= [list_contacts_bfr_ice, list_contacts_aft_ice_biases, contacts_per_frag]
	out 	:= [log, html]

	task( taskName := "hic6a $info", cpus := nth, timeout := parse_time(wt), mem := parse_mem(mem), \
		out<-in) {

		sys $SHCMD_INIT	

		//sys discBinsize=$(($(($dist_up_thres-$distLowThres))/$no_of_bins))
		sys discBinsize=$disc_bin_size
		sys echo ${discBinsize}

		sys date >> $log
		sys echo w=$w no_of_bins=$no_of_bins fit_mapp=$fit_mapp no_of_passes=$no_of_passes dist_up_thres=$dist_up_thres distLowThres=$distLowThres discBinsize=${discBinsize} residual_factor=$residual_factor>> $log 
		sys echo >> $log

		sys echo '<html>' > $html
		sys echo '<head><meta http-equiv= "content-type" content="text/html; charset=UTF-8"><title></title></head>' >> $html
		sys echo '<body>' >> $html
		sys echo '<table  border="1" >' >> $html
		sys echo '<tbody>' >> $html

		sys echo '<tr>' >> $html
		sys echo '<th scope="col"> Library label </th>' >> $html

		sys for t in `seq $(($no_of_passes+1))`; do \
			#echo '<th scope="col"> Equal occupancy binning </th>' >> $html; \
			echo '<th scope="col"> Fitting - power-law </th>' >> $html; \
			echo '<th scope="col"> Fitting - spline </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - power-law </th>' >> $html; \
			echo '<th scope="col"> Extract outliers - spline </th>' >> $html; \
			echo '<th scope="col"> FDR - compare all </th>' >> $html; \
			echo '<th scope="col"> FDR - spline </th>' >> $html; \
			echo '<th scope="col"> Binning bias </th>' >> $html; \
			done

		sys echo '</tr>' >> $html

		sys noOfCols=$((($no_of_passes+1)*7))
		sys echo '<tr>' >> $html
		sys echo '<th> </th>' >> $html
		sys for t in `seq ${noOfCols}`; do \
			echo '<th> '${t}' </th>' >> $html; \
			done
		sys echo '</tr>' >> $html

		sys if [[ $before_after == "afterICE" ]]; then \
			python $(which fit-hic-LATEST_std.py) -l "$id" -t $list_contacts_aft_ice_biases -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out; \
			else \
			python $(which fit-hic-LATEST_std.py) -l "$id" -f $contacts_per_frag -i $list_contacts_bfr_ice -L $distLowThres -U $dist_up_thres -b $no_of_bins -m $fit_mapp -p $no_of_passes -d ${discBinsize} -r $residual_factor -o $out_dir --comparisonMode --usebinning > $out_dir/$id.out; \
			fi

		sys echo '<tr>' >> $html
		sys echo '<td> $id </td>' >> $html
		sys for t in `seq $(($no_of_passes+1))`; do \
			echo '<td> <a href="$id.plaw_pass'${t}'.png"><img src="$id.plaw_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass'${t}'.png"><img src="$id.spline_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.plaw_pass'${t}'.extractOutliers.png"><img src="$id.plaw_pass'${t}'.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.spline_pass'${t}'.extractOutliers.png"><img src="$id.spline_pass'${t}'.extractOutliers.png" width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparison_pass'${t}'.png"><img src="$id.comparison_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.plaw_pass'${t}'.qplot.png"><img src="$id.plaw_pass'${t}'.qplot.png"  width=400> </a></td>' >> $html; \
			#echo '<td> <a href="$id.spline_pass'${t}'.qplot.png"><img src="$id.spline_pass'${t}'.qplot.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonDisc_pass'${t}'.png"><img src="$id.comparisonDisc_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			echo '<td> <a href="$id.comparisonFitDisc_pass'${t}'.png"><img src="$id.comparisonFitDisc_pass'${t}'.png"  width=400> </a></td>' >> $html; \
			done

		sys echo '<tr>' >> $html
		sys echo '</tbody></table>' >> $html
		sys echo '</body></html>' >> $html
	}
}

string get_cln_pair( int lib, int rep ) {

	key := "cln_pair" + lib + "_" + rep
	key2 := "cln_pair_L" + lib + "_R" + rep
	key3 := "cln_pair_R" + rep + "_L" + lib

	if ( cmd_line_arg_has_key( key ) ) {
		return get_cmd_line_arg_val( key )
	}
	else if ( cmd_line_arg_has_key( key2 ) ) {
		return get_cmd_line_arg_val( key2 )
	}	
	else if ( cmd_line_arg_has_key( key3 ) ) {
		return get_cmd_line_arg_val( key3 )
	}	
	else if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( conf.hasKey( key3 ) ) {
		return get_path( conf{ key3 } )
	}
	return ""
}

string get_id( int lib, int rep ) {

	return "$prefix"+"_"+lib_names[lib-1]+"_"+rep_names[rep-1]
}

string get_id( int lib ) {

	return "$prefix"+"_"+lib_names[lib-1]
}

string get_merge_name() {

	if ( merge == 0 ) {
		return "no_merge"
	}
	else if ( merge == 1 ) {
		return "reps_merged"
	}
	else if ( merge == 2 ) {
		return "all_merged"		
	}
}

string get_res_prefix() {

	if ( method.toLower() == "re" ) {
		return "RE"
	}
	else {
		return "w"
	}
}

bool is_method_RE() {
	return method.toLower() == "re"
}

bool is_method_fixed() {
	return method.toLower() == "fixed"	
}

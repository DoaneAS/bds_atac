#!/usr/bin/env bds

include "../chipseq/modules/fastq.bds"
include "../chipseq/modules/bam.bds"
include "../modules/align_etc.bds"
include "../modules/align_bowtie2.bds"
include "../modules/preseq.bds"
include "../chipseq/modules/peakcall_macs2.bds"
include "../chipseq/modules/report.bds"


help ATAC-Seq Pipeline setting : fragment length, # replicates
trimmed_fastq 	:= false	help Add it to skip fastq-trimming stage (default: false).
fraglen 	:= 75 		help Read fragment length (default: 75).
num_rep 	:= 1		help # replicates. ATAC seq for each replicate will go IN PARALLEL. (default: 1).
no_vplot	:= false 	help Add it to bypass V plot generation (default: false).
no_preseq 	:= false 	help Add it to bypass preseq analysis (default: false).
no_peakcall 	:= false	help Add it to skip MACS2 peak calling (default: false).


help()

init_atac()

chk_input_data()

set_shell_env()

atac()



void init_atac() {

	if ( conf_file_exists() ) {

		trimmed_fastq 	= get_conf_val_bool( trimmed_fastq,	["trimmed_fastq"] )
		fraglen 	= get_conf_val_int( fraglen,		["fraglen", "frag_len"] )
		num_rep 	= get_conf_val_int( num_rep,		["num_rep", "numrep"] )
		no_vplot 	= get_conf_val_bool( no_vplot,		["no_vplot"] )
		no_preseq 	= get_conf_val_bool( no_preseq,		["no_preseq"] )
		no_peakcall 	= get_conf_val_bool( no_peakcall,	["no_peakcall"] )
	}
	else if ( is_legacy_input() ) { // legacy input method taking first 8 parameters from cmd. line (num_rep=1)

		bwt2_idx 	= args[0].trim()
		fastq1_1	= args[1].trim()
		fastq1_2	= args[2].trim()
		nth_bwt2	= args[3].trim().parseInt()
		gensz		= args[4].trim()
		chrsz		= args[5].trim()
		vplot_idx 	= args[6].trim()
		out_dir 	= args[7].trim()

		if ( v ) { // verbose
			print("\n\n")
			print("Legacy input method found (8 parameters)\n")
			print("========================================\n")
			print( "Bowtie2 index\t\t: $bwt2_idx\n" )
			print( "Read 1\t\t\t: $fastq1_1\n" )
			print( "Read 2\t\t\t: $fastq1_2\n" )
			print( "# threads (bowtie2)\t: $nth_bwt2\n")
			print( "Genome size (hs,mm)\t: $gensz\n" )
			print( "Chromesizes file\t: $chrsz\n" )
			print( "V-Plot index\t\t: $vplot_idx\n" )
			print( "Output dir.\t\t: $out_dir\n" )
		}

		num_rep = 1
	}

	if ( v ) { // verbose
		print("\n")
		print( "Fastqs are trimmed?\t: $trimmed_fastq\n")
		print( "Fragment length\t\t: $fraglen\n")
		print( "# Replicates\t\t: $num_rep\n")
		print( "No vplot generation\t: $no_vplot\n")
		print( "No preseq analysis\t: $no_preseq\n")
		print( "No MACS2 peak calling\t: $no_peakcall\n")
	}
}

void chk_input_data() {

	if ( !path_exists("$bwt2_idx.1.bt2") ) error("\nBowtie2 index doesn't exists! ($bwt2_idx.1.bt2)\n")

	if ( !no_vplot && !path_exists( vplot_idx ) ) error("\nVPlot index doesn't exists! ($vplot_idx) \n")	

	if ( !path_exists( chrsz ) ) error("\nChrome sizes file doesn't exists! ($chrsz)\n")	

	string[] fastqs_all

	for ( int rep=1; rep <= num_rep; rep++) {

		string read1, read2

		fastqs := get_fastqs( 0, rep )

		if ( (num_rep==1) && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

		prefix := "Rep$rep fastq"
		print("$prefix :\n")

		for ( string s : fastqs ) {
			print("\t$s\n")
			if ( (s != "") && !path_exists(s) ) error("\t\tFile not found!\n")
		}

		// check any duplicate input filename
		for ( string s : fastqs ) {
			if ( is_in_array( get_basename( s ), get_basename( fastqs_all ) ) ) \
				error( "\tFilename is duplicate for $prefix!\n")
		}

		fastqs_all = concat( fastqs_all, fastqs )
	}
}

void atac() {

	for (int rep=1; rep<=num_rep; rep++) {
		if ( no_par_job ) {
			_atac( rep )
		}
		else {
			par _atac( rep )
		}
	}

	wait
}

void _atac( int rep ) {

	info := get_task_info( 0, rep ) // no info needed for atac

	fastqs := get_fastqs( 0, rep )

	if ( (num_rep==1) && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

	atac_out_dir := mkdir_path( (num_rep==1) ? out_dir : "$out_dir/$info" )

	string p1, p2

	if ( trimmed_fastq ) {
		print("\nSkipping trimming fastqs (-trimmed_fastq flag is on)\n\n")

		p1 = fastqs[0]
		p2 = fastqs[1]
	}
	else {
		( p1, p2 ) = _trim_adapters( fastqs[0], fastqs[1], atac_out_dir, info )
	}

	wait // hold parallel

	bam := _bowtie2( p1, p2, atac_out_dir, info )

	wait

	nodup_bam := _bam_to_nodup_bam_PE( bam, atac_out_dir, info )

	wait

	bed := _bam_to_bed_non_chrM( nodup_bam, atac_out_dir, info )

	wait

	if ( !no_peakcall ) {
		_macs2_bed( bed, "$fraglen", atac_out_dir, info )

		if ( no_par_job ) wait
	}

	string srt_bam

	if ( !no_vplot || !no_preseq ) srt_bam = _bam_to_srt_bam( bam, atac_out_dir, info )

	wait

	string png, pdf

	if ( !no_vplot ) {
		png = _vplot( srt_bam, atac_out_dir, info )

		if ( no_par_job ) wait
	}

	if ( !no_preseq ) {
		pdf = _preseq( srt_bam, atac_out_dir, info )
	}

	wait

	_report_atac( pdf, png, atac_out_dir, info )
}

string[] _report_atac( string pdf, string png, string out_dir, string info ) {

	tex_file := "$out_dir/report.tex"
	pdf_file := "$out_dir/report.pdf"

	// a lot of inputs so I picked up just two
	in 	:= [pdf, png]
	out 	:= [tex_file, pdf_file]

	task( taskName:= "report "+info, \
		cpus:=nth, mem:=parse_mem(mem), timeout:=parse_time(wt), \
		out<-in ) {

		sys $SHCMD_INIT

		sys cd $out_dir
		sys thisFolder=$out_dir

		//# figure out what we've aligned to
		sys MODEL=$bwt_idx

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys alignLog="$(echo *.align.log)"
		sys alignLogLastLine=$(tail -n 1 ${alignLog})

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys dupQCFile=$(echo *.dup.qc)
		sys dupQCHeadings=$(sed -n 7p ${dupQCFile})
		sys dupQCHeadings=${dupQCHeadings//_/\\\\_} #moar reformatting
		sys IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"

		sys dupQCData=$(sed -n 8p ${dupQCFile})
		sys IFS=$'\t' read -a dupQCData <<< "${dupQCData}"

		sys START=0
		sys END=${#dupQCHeadings[@]}
		sys DUPTABLE=""

		//## here we build up the tex styled table contents
		sys for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done

		//# library complexity data file name
		sys bpcQCFile=$(echo *.pbc.qc)

		//# library complexity data file contents
		sys declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair")
		sys bpcQC=$(cat ${bpcQCFile})
		sys IFS=$'\t' read -a bpcData <<< "${bpcQC}"

		sys START=0
		sys END=${#bpcLabels[@]}
		sys BPCTABLE=""

		//## here we build up the tex styled table contents
		sys for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done			

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $tex_file
		sys echo "\usepackage{graphicx}" >> $tex_file
		sys echo "\usepackage{multicol}" >> $tex_file
		sys echo "\usepackage{listings}" >> $tex_file
		sys echo "\usepackage{grffile}" >> $tex_file
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $tex_file
		sys echo "\usepackage{booktabs}" >> $tex_file
		sys echo "\usepackage{hyphenat}" >> $tex_file
		sys echo "\usepackage{fancyhdr}" >> $tex_file
		sys echo "\pagestyle{fancy}" >> $tex_file
		sys echo "\fancyhf{}" >> $tex_file
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $tex_file
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $tex_file
		sys echo "\begin{document}" >> $tex_file
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $tex_file
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $tex_file
		sys echo "\begin{multicols}{2}" >> $tex_file
		sys echo "\subsection{Genome Model}" >> $tex_file
		sys echo "${MODEL//_/\\_}" >> $tex_file

		sys if [[ $no_vplot == "false" ]]; then \
			echo "\subsection{V-Plot}" >> $tex_file; \
			echo "From ${vPlot//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $tex_file; \
			fi

		sys if [[ $no_preseq == "false" ]]; then \
			echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $tex_file; \
			echo "From ${preseqGraph//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $tex_file; \
			fi

		sys echo "\subsection{Library Complexity}" >> $tex_file
		sys echo "From ${bpcQCFile//_/\\_}:\\\\" >> $tex_file
		sys echo "\centerline{" >> $tex_file
		sys echo "\begin{tabular}{l|c}" >> $tex_file
		sys echo "\toprule" >> $tex_file
		sys echo "${BPCTABLE}" >> $tex_file
		sys echo "\end{tabular}" >> $tex_file
		sys echo "}" >> $tex_file
		sys echo "\subsection{Insert size histogram}" >> $tex_file
		sys echo "From ${insertSizeHist//_/\\_}:\\\\" >> $tex_file
		sys echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $tex_file
		sys echo "\subsection{Picard Duplication Metrics}" >> $tex_file
		sys echo "From ${dupQCFile//_/\\_}:\\\\" >> $tex_file
		sys echo "\begin{tabular}{l|c}" >> $tex_file
		sys echo "\toprule" >> $tex_file
		sys echo "${DUPTABLE}" >> $tex_file
		sys echo "\end{tabular}" >> $tex_file
		sys echo "\subsection{bowtie2 Alignment Log}" >> $tex_file
		sys echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $tex_file
		sys echo "From ${alignLog//_/\\_}:\\\\" >> $tex_file
		sys echo "\scalebox{.6}{" >> $tex_file
		sys echo "\lstinputlisting{${alignLog}}" >> $tex_file
		sys echo "}" >> $tex_file
		sys echo "\end{multicols}  " >> $tex_file
		sys echo "%\pagebreak" >> $tex_file
		sys echo "\end{document}" >> $tex_file		

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $out_dir
		sys pdflatex $tex_file
	}

	return out
}

void set_shell_env() {
	
	// create output dir.	

	if ( is_kundaje_lab() ) {

		print("\n\nAutomatically adding environment variables... (kundaje_lab: $hostname) \n\n")

		if ( SHCMD_INIT.indexOf( init_mod ) < 0  ) { // if not module init. cmd found, then add it
			SHCMD_INIT = SHCMD_INIT + " . /etc/profile.d/modules.sh;"
		}

		if ( is_scg3() ) { // if on SCG3		
			SHCMD_INIT = SHCMD_INIT + " module add gnuplot/5.0 python/2.7;" \
		}

		SHCMD_INIT = SHCMD_INIT + " module add bowtie/2.2.4 samtools/1.2 bedtools/2.21.0;" \
					+ " module add picard-tools/1.129 ucsc_tools/3.0.9 MACS2/2.1.0 java/latest;" \
					+ " module add preseq/1.0.2 texlive/2013;" \
					+ " export _JAVA_OPTIONS='-Xms256M -Xmx512M -XX:ParallelGCThreads=1'; export MAX_JAVA_MEM='8G'; export MALLOC_ARENA_MAX=4"
		SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )

		if ( v ) { // verbose
			print( "Final shell cmd. for init.\t: $SHCMD_INIT\n" )
		}
	}
}

void help() {

	if ( is_cmd_line_arg_empty() ) {

		print("\n")
		print(" Usage 1 (command line argument, legacy input method): \n")
		print("\n")
		print("\t\$ bds atac.bds [BOWTIE_INDEX] [READ1] [READ2] [NTHREADS_BWT2] [GENOMESIZE] [CHROMSIZES] [VPLOT_INDEX] [OUTPUT_DIR] \n")
		print("\n")
		print(" Usage 2 (command line argument): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -fastq1 [READ1] \\ \n")
		print("\t\t -fastq2 [READ2] \\ \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -vplot_idx [VPLOT_INDEX] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\n")
		print(" Usage 3 (configruation file): \n")
		print("\n")
		print("\t\$ bds atac.bds [CONF_FILE]\n")
		print("\n")
		print("\t=== [CONF_FILE] contents ===\n")
		print("\tbwa_idx= [BOWTIE_INDEX]\n")
		print("\tfastq1= [READ1]\n")
		print("\tfastq2= [READ2]\n")
		print("\tnth_bwt2= [NTHREADS_BWT2]\n")
		print("\tgensz= [GENOMESIZE]\n")
		print("\tchrsz= [CHROMSIZES]\n")
		print("\tvplot_idx= [VPLOT_INDEX]\n")
		print("\tout_dir= [OUTPUT_DIR]\n")
		print("\n")
		print(" Usage 4 (command line argument, multiple replicates): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -rep_num [NUMBER_OF_REPLICATES] \\ \n")
		print("\t\t -fastq1_1 [REP1_READ1] \\ \n")
		print("\t\t -fastq1_2 [REP1_READ2] \\ \n")
		print("\t\t -fastq2_1 [REP2_READ1] \\ \n")
		print("\t\t -fastq2_2 [REP2_READ2] \\ \n")
		print("\t\t ... \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -vplot_idx [VPLOT_INDEX] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\n")
		print(" For Sun Grid Engine (SGE) cluster use\n")
		print("\n")
		print("\t\$ bds -s sge atac.bds ... \n")
		print("\n")
		print(" List of parameters\n")
		print(" \n")
		printHelp()

		exit
	}
}

string get_task_info( int ctl, int rep ) {

	return ( (ctl>0) ? "ctl_" : "") + "rep" + rep
}

bool is_legacy_input() {

	bool ret

	if ( args.size() >= 8 ) {
		ret = true

		for (int i=0; i<8;i++) {
			
			if ( args[i].startsWith("-") ) {
				ret = false
				break
			}
		}
	}

	return ret
}

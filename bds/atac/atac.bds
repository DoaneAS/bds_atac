#!/usr/bin/env bds


trimmed_fastq 	:= false	help Skip fastq-trimming stage.
fraglen 	:= 75 		help Read fragment length (default: 75).

mapping	 	:= false	help Mapping only (no MACS2 peak calling).
vplot 		:= false 	help Create V plot.
preseq 		:= false 	help Do preseq analysis.
subsample 	:= false 	help Subsample replicates. Use '-nreads [NO_READS]' to specify # reads to subsample.
pseudorep 	:= false 	help Generate pseudo-replicates and call peaks on them.
idr 		:= false 	help Perform IDR analysis.

include "../chipseq/modules/input_fastq.bds"
include "../chipseq/modules/input_bam.bds"
include "../chipseq/modules/align_bowtie2.bds"
include "../chipseq/modules/align_etc.bds"
include "../chipseq/modules/postalign_bam.bds"
include "../chipseq/modules/postalign_bed.bds"
include "../chipseq/modules/preseq.bds"
include "../chipseq/modules/callpeak_macs2.bds"
include "../chipseq/modules/idr.bds"

input := ""

// Global variable for output filenames ( map with key $rep )
string{} peaks, peaks_pr1, peaks_pr2 	
string{} shifted_tags, shifted_tags_pr1, shifted_tags_pr2



help()

init_atac()

chk_input_data()

set_shell_env()

atac()

do_idr()


void init_atac() {

	if ( conf_file_exists() ) {

		trimmed_fastq 	= get_conf_val_bool( trimmed_fastq,	["trimmed_fastq"] )
		fraglen 	= get_conf_val_int( fraglen,		["fraglen", "frag_len"] )

		mapping		= get_conf_val_bool( mapping,		["mapping"] )

		vplot 		= get_conf_val_bool( vplot,		["vplot"] )
		preseq 		= get_conf_val_bool( preseq,		["preseq"] )
		subsample	= get_conf_val_bool( subsample, 	["subsample"] )
		pseudorep	= get_conf_val_bool( pseudorep, 	["pseudorep"] )

		idr 		= get_conf_val_bool( idr, 		["idr"] )
	}
	else if ( is_input_legacy() ) { // legacy input method taking first 8 parameters from cmd. line

		bwt2_idx 	= args[0].trim()
		fastq1_1	= args[1].trim()
		fastq1_2	= args[2].trim()
		nth_bwt2	= args[3].trim().parseInt()
		gensz		= args[4].trim()
		chrsz		= args[5].trim()
		vplot_idx 	= args[6].trim()
		out_dir 	= args[7].trim()

		vplot 		= true
		preseq 		= true

		mapping 	= false

		idr 		= false

		input 		= "fastq"
	
		if ( v ) { // verbose
			print("\n\n")
			print("Legacy input method found (8 parameters)\n")
			print("========================================\n")
			print( "Bowtie2 index\t\t: $bwt2_idx\n" )
			print( "Read 1\t\t\t: $fastq1_1\n" )
			print( "Read 2\t\t\t: $fastq1_2\n" )
			print( "# threads (bowtie2)\t: $nth_bwt2\n")
			print( "Genome size (hs,mm)\t: $gensz\n" )
			print( "Chromosome sizes file\t: $chrsz\n" )
			print( "V-Plot index\t\t: $vplot_idx\n" )
			print( "Output dir.\t\t: $out_dir\n" )
		}		
	}

	if ( v ) { // verbose
		print("\n")
		print( "Input data type\t\t: $input\n")		
		print( "Fastqs are trimmed?\t: $trimmed_fastq\n")
		print( "Fragment length\t\t: $fraglen\n")
		print( "# Replicates\t\t: "+ get_num_rep() + "\n")
		print( "Vplot generation\t: $vplot\n")
		print( "Preseq analysis\t\t: $preseq\n")
		print( "MACS2 peak calling\t: " + !mapping + "\n")
		print( "Subsample replicates\t: $subsample\n")
		print( "Create/call peaks on pseudo replicates\t: $pseudorep\n")
		print( "Perform IDR analysis on peaks\t: $idr\n")
	}
}

void chk_input_data() {

	if ( input == "" ) { // determine input type
		
		if ( get_filt_bam(0,1) != "" ) 	input = "filt_bam"
		if ( get_bam(0,1) != "" ) 	input = "bam"
		if ( get_fastq(0,1,1) != "" ) 	input = "fastq"
	}

	if ( is_input_fastq() && !path_exists("$bwt2_idx.1.bt2") ) error("\nBowtie2 index doesn't exists! ($bwt2_idx.1.bt2)\n")

	if ( vplot && !path_exists( vplot_idx ) ) error("\nVPlot index doesn't exists! ($vplot_idx) \n")	

	if ( !mapping && !path_exists( chrsz ) ) error("\nChromosome sizes file doesn't exists! ($chrsz)\n")	

	print("\n")

	if ( is_input_fastq() ) {

		string[] fastqs_all

		for ( int rep=1; rep <= get_num_rep(); rep++) {

			string read1, read2

			fastqs := get_fastqs( 0, rep )

			if ( fastqs.size()==0 ) error("No fastq defined for replicate $rep\n")

			if ( get_num_rep()==1 && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

			prefix := "Rep$rep fastq"
			print("$prefix :\n")

			for ( string s : fastqs ) {
				print("\t$s\n")
				if ( (s != "") && !path_exists(s) ) error("\t\tFile not found!\n")
			}

			// check any duplicate input filename
			for ( string s : fastqs ) {
				if ( is_in_array( get_basename( s ), get_basename( fastqs_all ) ) ) \
					error( "\tFilename is duplicate for $prefix!\n")
			}

			if ( fastqs.size() != 2 ) error("\tNeeds two fastqs for replicate $rep.\n")

			fastqs_all = concat( fastqs_all, fastqs )
		}
	}
	else if ( is_input_bam() ) {

		string[] bams_all

		for ( int rep=1; rep <= get_num_rep(); rep++) {

			bam := get_bam( 0, rep )

			if ( bam == "" ) error("No bam defined for replicate $rep\n")

			prefix := "Rep$rep bam"
			print("$prefix :\n")

			print("\t$bam\n")
			if ( !path_exists(bam) ) error("\t\tFile not found!\n")

			// check any duplicate input filename
			if ( is_in_array( get_basename( bam ), get_basename( bams_all ) ) ) \
				error( "\tFilename is duplicate for $prefix!\n")

			bams_all.add( bam )
		}
	}
	else if ( is_input_filt_bam() ) {

		string[] bams_all

		for ( int rep=1; rep <= get_num_rep(); rep++) {

			bam := get_filt_bam( 0, rep )

			if ( bam == "" ) error("No filt_bam defined for replicate $rep\n")

			prefix := "Rep$rep filt_bam"
			print("$prefix :\n")

			print("\t$bam\n")
			if ( !path_exists(bam) ) error("\t\tFile not found!\n")

			// check any duplicate input filename
			if ( is_in_array( get_basename( bam ), get_basename( bams_all ) ) ) \
				error( "\tFilename is duplicate for $prefix!\n")

			bams_all.add( bam )
		}
	}
	else {
		error("Unsupported file type!\n")
	}

	if ( is_input_filt_bam() ) {

		print("\n\nPreseq analysis and vplot are not available if pipeline starts from filtered bam files (with '-input filt_bam')!\n")

		vplot 	= false
		preseq 	= false
	}
}

void atac() {

	for (int rep=1; rep<=get_num_rep(); rep++) {
		
		if ( no_par_job )   _atac( rep )
		else 		par _atac( rep )
	}
	wait
}

void _atac( int rep ) {

	info := get_task_info( 0, rep )

	atac_out_dir := mkdir_path( (get_num_rep()==1) ? out_dir : "$out_dir/$info" )

	string bam, filt_bam, dup_qc

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )

		// correct if user skipped replicate id like (-fastq[PAIR]) instead of (-fastq[REP]_[PAIR])
		if ( (get_num_rep()==1) && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

		string p1, p2

		if ( trimmed_fastq ) {

			p1 = fastqs[0]
			p2 = fastqs[1]
		}
		else {
			( p1, p2 ) = _trim_adapters( fastqs[0], fastqs[1], atac_out_dir, info )
		}

		wait

		bam = _bowtie2( p1, p2, atac_out_dir, info )
		wait
		
		(filt_bam, dup_qc) = _dedup_bam_PE( bam, atac_out_dir, info )
	}
	else if ( is_input_bam() ) {

		bam = get_bam( 0, rep )

		(filt_bam, dup_qc) = _dedup_bam_PE( bam, atac_out_dir, info )
	}
	else if ( is_input_filt_bam() ) {

		filt_bam = get_filt_bam( 0, rep )
	}

	wait

	if ( !mapping ) {

		if ( subsample || pseudorep ) {

			nmsrt_bam := _nmsrt_bam( filt_bam, atac_out_dir, info )
			wait

			bedpe := _bam_to_bedpe( nmsrt_bam, atac_out_dir, info )
			wait 

			string subsampled_bedpe

			if ( subsample ) {

				subsampled_bedpe = _subsample_bedpe( bedpe, atac_out_dir, info )		
			}
			else {
				subsampled_bedpe = bedpe
			}
			wait

			tag := _bedpe_to_tag( subsampled_bedpe, atac_out_dir, info )			
			wait

			shifted_tags{rep} = _shift_tag( tag, atac_out_dir, info )			 
			
			if ( pseudorep ) {

				string tag_pr1, tag_pr2
				(tag_pr1, tag_pr2) = _spr_PE( subsampled_bedpe, atac_out_dir, info )
				wait

				shifted_tags_pr1{rep} = _shift_tag( tag_pr1, atac_out_dir, info )
				shifted_tags_pr2{rep} = _shift_tag( tag_pr2, atac_out_dir, info )
			}
			wait

			peaks{rep} = _macs2_atac( shifted_tags{rep}, "$fraglen", atac_out_dir, info )
			
			if ( pseudorep ) {

				peaks_pr1{rep} = _macs2_atac( shifted_tags_pr1{rep}, "$fraglen", atac_out_dir, info + "_pr1" )
				peaks_pr2{rep} = _macs2_atac( shifted_tags_pr2{rep}, "$fraglen", atac_out_dir, info + "_pr2")
			}
		}
		else {

			shifted_tags{rep} = _bam_to_bed_atac( filt_bam, atac_out_dir, info )
			wait

			peaks{rep} = _macs2_atac( shifted_tags{rep}, "$fraglen", atac_out_dir, info )
		}
	}

	string sorted_bam

	if ( vplot || preseq ) sorted_bam = _srt_bam( bam, atac_out_dir, info )
	wait

	string png, pdf

	if ( vplot ) png = _vplot( sorted_bam, atac_out_dir, info )
	
	if ( preseq ) pdf = _preseq( sorted_bam, atac_out_dir, info )
	wait

	_report_atac( pdf, png, atac_out_dir, info )
}

void do_idr() {
	
	if ( !idr || get_num_rep() != 2 ) return

	idr_out_dir := mkdir_path( use_idr1 ? "$out_dir/idr1" : "$out_dir/idr2" )

	shifted_tag_pooled := _pool_tag( shifted_tags{1}, shifted_tags{2}, idr_out_dir, "" )
	wait

	peak_pooled := _macs2_atac( shifted_tag_pooled, "$fraglen", idr_out_dir, "pooled" )
	wait

	// IDR for true reps
	idr_Nt := _idr( peaks{1}, peaks{2}, peak_pooled, idr_out_dir, "true_rep_Rep1_vs_Rep2" )

	if ( pseudorep ) {

		// IDR on pseudo reps
		idr_N1 := _idr( peaks_pr1{1}, peaks_pr2{1}, peaks{1}, idr_out_dir, "pseudo_rep_Rep1_PR1_vs_Rep1_PR2" )
		idr_N2 := _idr( peaks_pr1{2}, peaks_pr2{2}, peaks{2}, idr_out_dir, "pseudo_rep_Rep2_PR1_vs_Rep2_PR2" )

		// Make shifted tags for pooled pseudo rep (ppr).
		string shifted_tag_pooled, shifted_tag_ppr1, shifted_tag_ppr2

		( shifted_tag_pooled, shifted_tag_ppr1, shifted_tag_ppr2 ) = \
			_ppr( 	shifted_tags{1}, shifted_tags_pr1{1}, shifted_tags_pr2{1}, \
				shifted_tags{2}, shifted_tags_pr1{2}, shifted_tags_pr2{2}, idr_out_dir, "" )
		wait

		// call peaks on ppr
		peak_ppr1 := _macs2_atac( shifted_tag_ppr1, "$fraglen", idr_out_dir, "ppr1" )
		peak_ppr2 := _macs2_atac( shifted_tag_ppr2, "$fraglen", idr_out_dir, "ppr2" )
		wait

		// IDR on ppr
		idr_Np := _idr( peak_ppr1, peak_ppr2, peak_pooled, idr_out_dir, "pooled_pseudo_rep_PPR1_vs_PPR2" )
		wait

		// second entry of output from function _idr() is narrowpeak.gz, get final idr qc score
		idr_final_score := _idr_final_qc( idr_Nt[1], idr_N1[1], idr_N2[1], idr_Np[1], idr_out_dir, "" )
	}

	wait
}

string[] _report_atac( string pdf, string png, string out_dir, string info ) {

	tex_file := "$out_dir/report.tex"
	pdf_file := "$out_dir/report.pdf"

	// a lot of inputs so I picked up just two
	//in 	:= [pdf, png]
	in 	:= ""
	out 	:= [tex_file, pdf_file]

	task( taskName:= "report "+info, \
		cpus:=nth, mem:=parse_mem_or_skip(memory), timeout:=parse_time_or_skip(wt), \
		out<-in ) {

		sys $SHCMD_INIT

		sys cd $out_dir
		sys thisFolder=$out_dir

		//# figure out what we've aligned to
		sys MODEL=$bwt_idx

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys if [[ $input == "fastq" ]]; then \
			alignLog="$(echo *.align.log)"; \
			alignLogLastLine=$(tail -n 1 ${alignLog}); \
			fi

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys if [[ $input == "fastq" ]]; then \
			dupQCFile=$(echo *.dup.qc); \
			dupQCHeadings=$(sed -n 7p ${dupQCFile}); \
			dupQCHeadings=${dupQCHeadings//_/\\\\_}; \
			IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"; \
			dupQCData=$(sed -n 8p ${dupQCFile}); \
			IFS=$'\t' read -a dupQCData <<< "${dupQCData}"; \
			START=0; \
			END=${#dupQCHeadings[@]}; \
			DUPTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			bpcQCFile=$(echo *.pbc.qc); \
			declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair"); \
			bpcQC=$(cat ${bpcQCFile}); \
			IFS=$'\t' read -a bpcData <<< "${bpcQC}"; \
			START=0; \
			END=${#bpcLabels[@]}; \
			BPCTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			fi

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $tex_file
		sys echo "\usepackage{graphicx}" >> $tex_file
		sys echo "\usepackage{multicol}" >> $tex_file
		sys echo "\usepackage{listings}" >> $tex_file
		sys echo "\usepackage{grffile}" >> $tex_file
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $tex_file
		sys echo "\usepackage{booktabs}" >> $tex_file
		sys echo "\usepackage{hyphenat}" >> $tex_file
		sys echo "\usepackage{fancyhdr}" >> $tex_file
		sys echo "\pagestyle{fancy}" >> $tex_file
		sys echo "\fancyhf{}" >> $tex_file
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $tex_file
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $tex_file
		sys echo "\begin{document}" >> $tex_file
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $tex_file
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $tex_file
		sys echo "\begin{multicols}{2}" >> $tex_file
		sys echo "\subsection{Genome Model}" >> $tex_file
		sys echo "${MODEL//_/\\_}" >> $tex_file

		sys if [[ $vplot == "true" ]]; then \
			echo "\subsection{V-Plot}" >> $tex_file; \
			echo "From ${vPlot//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $tex_file; \
			fi

		sys if [[ $preseq == "true" ]]; then \
			echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $tex_file; \
			echo "From ${preseqGraph//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $tex_file; \
			fi

		sys if [[ $input == "fastq" ]]; then \
			echo "\subsection{Library Complexity}" >> $tex_file; \
			echo "From ${bpcQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\centerline{" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${BPCTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "}" >> $tex_file; \
			echo "\subsection{Insert size histogram}" >> $tex_file; \
			echo "From ${insertSizeHist//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $tex_file; \
			echo "\subsection{Picard Duplication Metrics}" >> $tex_file; \
			echo "From ${dupQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${DUPTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "\subsection{bowtie2 Alignment Log}" >> $tex_file; \
			echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $tex_file; \
			echo "From ${alignLog//_/\\_}:\\\\" >> $tex_file; \
			echo "\scalebox{.6}{" >> $tex_file; \
			echo "\lstinputlisting{${alignLog}}" >> $tex_file; \
			echo "}" >> $tex_file; \
			fi

		sys echo "\end{multicols}  " >> $tex_file
		sys echo "%\pagebreak" >> $tex_file
		sys echo "\end{document}" >> $tex_file		

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $out_dir
		sys pdflatex $tex_file
	}

	return out
}

void set_shell_env() {
	
	// create output dir.	

	if ( is_kundaje_lab() || is_scg3() ) {

		print("\n\nAutomatically adding environment variables... (kundaje_lab: $hostname) \n\n")

		if ( SHCMD_INIT.indexOf( init_mod ) < 0  ) { // if not module init. cmd found, then add it
			SHCMD_INIT = SHCMD_INIT + " . /etc/profile.d/modules.sh;"
		}

		if ( is_scg3() ) { // if on SCG3		
			SHCMD_INIT = SHCMD_INIT + " module add gnuplot/5.0 python/2.7.6;" \
		}

		SHCMD_INIT = SHCMD_INIT + " module add bowtie/2.2.4 samtools/1.2 bedtools/2.21.0;" \
					+ " module add picard-tools/1.129 ucsc_tools/3.0.9 MACS2/2.1.0 java/latest;" \
					+ " module add preseq/1.0.2 texlive/2013;" \
					+ " export _JAVA_OPTIONS='-Xms256M -Xmx2048M -XX:ParallelGCThreads=1'; export MAX_JAVA_MEM='16G'; export MALLOC_ARENA_MAX=4"
		SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )

		if ( v ) { // verbose
			print( "Final shell cmd. for init.\t: $SHCMD_INIT\n" )
		}
	}
}

void help() {

	if ( is_cmd_line_arg_empty() ) {

		print("\n")
		print(" Usage 1 (command line argument, legacy input method): \n")
		print("\n")
		print("\t\$ bds atac.bds [BOWTIE_INDEX] [READ1] [READ2] [NTHREADS_BWT2] [GENOMESIZE] [CHROMSIZES] [VPLOT_INDEX] [OUTPUT_DIR] \n")
		print("\n")
		print(" Usage 2 (command line argument): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -fastq1 [READ1] \\ \n")
		print("\t\t -fastq2 [READ2] \\ \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\n")
		print("\tIf you want V plot generation add the following:\n")
		print("\t\t -vplot -vplot_idx [VPLOT_INDEX]\n")
		print("\n")
		print("\tIf you want preseq analysis add the following:\n")
		print("\t\t -preseq\n")
		print("\n")
		print("\tIf you don't want MACS2 peak calling add the following:\n")
		print("\t\t -mapping\n")
		print("\n")
		print(" Usage 3 (configruation file): \n")
		print("\n")
		print("\t\$ bds atac.bds [CONF_FILE]\n")
		print("\n")
		print("\t=== [CONF_FILE] contents ===\n")
		print("\tbwa_idx= [BOWTIE_INDEX]\n")
		print("\tfastq1= [READ1]\n")
		print("\tfastq2= [READ2]\n")
		print("\tnth_bwt2= [NTHREADS_BWT2]\n")
		print("\tgensz= [GENOMESIZE]\n")
		print("\tchrsz= [CHROMSIZES]\n")
		print("\tout_dir= [OUTPUT_DIR]\n")
		print("\tvplot= [NEED_VPLOT_GENERATION]\n")
		print("\tvplot_idx= [VPLOT_INDEX]\n")
		print("\tpreseq= [NEED_PRESEQ_ANALYSIS]\n")
		print("\n")
		print(" Usage 4 (command line argument, multiple replicates): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -rep_num [NUMBER_OF_REPLICATES] \\ \n")
		print("\t\t -fastq1_1 [REP1_READ1] \\ \n")
		print("\t\t -fastq1_2 [REP1_READ2] \\ \n")
		print("\t\t -fastq2_1 [REP2_READ1] \\ \n")
		print("\t\t -fastq2_2 [REP2_READ2] \\ \n")
		print("\t\t ... \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\t\t -vplot -vplot_idx [VPLOT_INDEX] \\ \n")
		print("\t\t -preseq \\ \n")
		print("\n")
		print(" For Sun Grid Engine (SGE) cluster use\n")
		print("\n")
		print("\t\$ bds -s sge atac.bds ... \n")
		print("\n")
		print(" List of parameters\n")
		print(" \n")
		printHelp()

		exit
	}
}

string get_task_info( int ctl, int rep ) {

	return ( (ctl>0) ? "ctl_" : "") + "rep" + rep
}

bool is_input_legacy() {

	bool ret

	if ( args.size() >= 8 ) {
		ret = true

		for (int i=0; i<8;i++) {
			
			if ( args[i].startsWith("-") ) {
				ret = false
				break
			}
		}
	}

	return ret
}

bool is_input_fastq() {

	return input.toLower() == "fastq"
}

bool is_input_bam() {

	return input.toLower() == "bam"
}

bool is_input_filt_bam() {

	return input.toLower() == "filt_bam"
}

int get_num_rep() {

	if ( is_input_legacy() ) 	return 1

	else if ( is_input_fastq() ) {

		if ( get_num_rep_fastq()==2 ) {

			fastqs := get_fastqs( 0, 1 )			

			if ( fastqs.size()<2 ) return 1
		}

		return get_num_rep_fastq()
	}
	else if ( is_input_bam() )  	return get_num_rep_bam()
	else if ( is_input_filt_bam() ) return get_num_rep_filt_bam()

	return 0
}

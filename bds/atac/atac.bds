#!/usr/bin/env bds

include "../pipeline"

// input reads
string READ1 		= ""			help Read1 fastq.gz
string READ2		= ""			help Read2 fastq.gz

///////// trimAdapters 
string TRIM_ADAPTERS 	= "trimAdapters.py"

///////// alignATAC 
string BOWTIE_IDX	= ""			help Path for bowtie index
int NUMTHREADS 		= 1			help Number of threads for bowtie2 (Default: 1)
int MEMORY_BWT2 	= 8000			// 2G was not enough

///////// alignPostprocessPE 
int MAPQ_THRESH 	= 30					
string JVM_OPTS 	= "-Xmx4G -Xms256M"
string MAKE_VPLOT 	= "makeVPlot.py"
string V_INDEX 					help Index for v-plot

//////// alignPostprocessATAC
string ADJUST_BED_TN5	= "adjustBedTn5.sh"

//////// callATACpeaks
string GENOMESIZE 	= "hs"			help 'hs' for human, 'mm' for mouse (Default: 'hs')
string CHROMSIZE	= ""			help Path for chrom.sizes file for your reference genome
int fragLen 		= 75						


// program body

PREFIX = 'atac' // redundant

print("IMPORTANT! ADD YOUR ATAC SCRIPT (*.sh; *.py) DIRECTORY BY USING -addpath")
print("bds atac.bds [PARAM1] ... [PARAM8] -addpath /your/atac/script/path")

read_param_general()
read_param_atac()
main_atac()





void read_param_atac() {

	if ( conf_file_exists() ) {

		///////// trimAdapters /////////////////////
		if ( conf.hasKey("READ1") )			READ1		= chk_file( conf{ "READ1" }, "" )
		if ( conf.hasKey("READ2") )			READ2		= chk_file( conf{ "READ2" }, "" )

		///////// alignATAC /////////////////////
		if ( conf.hasKey("BOWTIE_IDX") )		BOWTIE_IDX	= chk_file( conf{ "BOWTIE_IDX" }, ".1.bt2" )
		if ( conf.hasKey("NUMTHREADS") )		NUMTHREADS	= parse_int( conf{ "NUMTHREADS" } )
		if ( conf.hasKey("MEMORY_BWT2") )		MEMORY_BWT2	= parse_int( conf{ "MEMORY_BWT2" } )
		
		///////// alignPostprocessPE /////////////////////
		if ( conf.hasKey("MAPQ_THRESH") )		MAPQ_THRESH 	= parse_int( conf{ "MAPQ_THRESH" } )
		if ( conf.hasKey("JVM_OPTS") )			JVM_OPTS 	= rm_comment( conf{ "JVM_OPTS"} )
		if ( conf.hasKey("V_INDEX") )			V_INDEX 	= rm_comment( conf{ "V_INDEX"} )

		//////// callATACpeaks ////////
		if ( conf.hasKey("GENOMESIZE") )		GENOMESIZE	= rm_comment( conf{"GENOMESIZE"} )	
		if ( conf.hasKey("CHROMSIZE") )			CHROMSIZE	= chk_file( conf{"CHROMSIZE"}, "" )
		if ( conf.hasKey("fragLen") )			fragLen 	= parse_int( conf{ "fragLen" } )
	}
	else { // if there is no conf. file take first five arguments as input
		BOWTIE_IDX 	= chk_file( args[0], ".1.bt2" )
		READ1 		= chk_file( args[1], "" )
		READ2 		= chk_file( args[2], "" )
		NUMTHREADS	= args[3].parseInt()
		GENOMESIZE	= args[4]
		CHROMSIZE	= chk_file( args[5], "" )
		V_INDEX 	= chk_file( args[6], "" )
		OUTPUT_DIR 	= mkdir_path( args[7] )
	}

	print("READ1 = $READ1\n");
	print("READ2 = $READ2\n");
	print("TRIM_ADAPTERS = $TRIM_ADAPTERS\n");
	print("BOWTIE_IDX = $BOWTIE_IDX\n");
	print("NUMTHREADS = $NUMTHREADS (for bowtie2)\n");
	print("MEMORY_BWT2 = $MEMORY_BWT2 (megabytes)\n");
	print("MAPQ_THRESH = $MAPQ_THRESH\n");
	print("JVM_OPTS = $JVM_OPTS\n");
	print("ADJUST_BED_TN5 = $ADJUST_BED_TN5\n");
	print("GENOMESIZE = $GENOMESIZE\n");
	print("CHROMSIZE = $CHROMSIZE\n");
	print("fragLen = $fragLen\n");
}

void main_atac() {

	print( "\ntrimAdapters...\n" )

	// inputs
	P1_IN := READ1
	P2_IN := READ2

	// outputs (on OUTPUT_DIR)
	P1_OUT := OUTPUT_DIR + "/" + P1_IN.baseName().replace(".fastq.gz",".trim.fastq")
	P2_OUT := OUTPUT_DIR + "/" + P2_IN.baseName().replace(".fastq.gz",".trim.fastq")

	task( taskName := "trimAdapters", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 [P1_OUT, P2_OUT] <- [P1_IN, P2_IN] ) {

		sys $PRELOAD

		sys cd $OUTPUT_DIR
		sys python $(which $TRIM_ADAPTERS) -a $P1_IN -b $P2_IN
	}

	wait

	print( "\nalignATAC...\n" )

	READ1 = P1_OUT
	READ2 = P2_OUT

	//OFPREFIX := OUTPUT_DIR + "/" + PREFIX
	OFPREFIX := P1_OUT.replace(".fastq","")

	outputBAM := "$OFPREFIX.bam"
	outputLog := "$OFPREFIX.align.log"

	task( taskName := "alignATAC", cpus := NUMTHREADS, timeout := WALLTIME, mem := MEMORY_BWT2 * M, \
		 [outputBAM, outputLog] <- [READ1, READ2] ) {

		sys $PRELOAD

		sys bowtie2 -X2000 --threads "$NUMTHREADS" -x "$BOWTIE_IDX" \
			-1 <(zcat -f "$READ1") -2 <(zcat -f "$READ2") \
			2>"$outputLog" | \
			samtools view -bS - > "$outputBAM"
	}

	wait


	print( "\nalignPostprocessPE...\n" )

	RAW_BAM_FILE	:= outputBAM	

	FILT_BAM_PREFIX := "$OFPREFIX.filt.srt"
	FILT_BAM_FILE 	:= "$FILT_BAM_PREFIX.bam"

	TMP_FILT_BAM_PREFIX := "$FILT_BAM_PREFIX.nmsrt.tmp"
	TMP_FILT_BAM_FILE 	:= "$TMP_FILT_BAM_PREFIX.bam"

	TMP_FILT_BAM_FILE2	:= "$FILT_BAM_PREFIX.dupmark.bam"
	DUP_FILE_QC 		:= "$FILT_BAM_PREFIX.dup.qc"

	FINAL_BAM_PREFIX 		:= "$OFPREFIX.filt.srt.nodup"
	FINAL_BAM_FILE 			:= "$FINAL_BAM_PREFIX.bam" //# To be stored
	FINAL_BAM_INDEX_FILE 	:= "$FINAL_BAM_PREFIX.bai"
	FINAL_BAM_FILE_MAPSTATS := "$FINAL_BAM_PREFIX.flagstat.qc" //# QC file
	FINAL_NMSRT_BAM_PREFIX 	:= "$OFPREFIX.filt.nmsrt.nodup"
	FINAL_NMSRT_BAM_FILE 	:= "$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

	PBC_FILE_QC := "$FINAL_BAM_PREFIX.pbc.qc"


	// 
	if ( [PBC_FILE_QC, FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, FINAL_NMSRT_BAM_FILE, FINAL_BAM_FILE] <- RAW_BAM_FILE ) {

		task( taskName := "alignPostprocessPE (filt & sort)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			 FILT_BAM_FILE <- RAW_BAM_FILE ) {

			sys $PRELOAD

			//# =============================
			//# Remove unmapped, mate unmapped
			//# not primary alignment, reads failing platform
			//# Remove low MAPQ reads
			//# Only keep properly paired reads
			//# Obtain name sorted BAM file
			//# ==================

			sys echo "Filter reads and sort"

			//# Will produce name sorted BAM
			sys samtools view -F 1804 -f 2 -q "$MAPQ_THRESH" -u "$RAW_BAM_FILE" | \
				samtools sort -n - "$TMP_FILT_BAM_PREFIX" 

			//# Remove orphan reads (pair was removed)
			//# and read pairs mapping to different chromosomes
			//# Obtain position sorted BAM

			sys echo "Fix mates - orphans and cross chromosomes"

			//# Will produce coordinate sorted BAM
			sys samtools fixmate -O bam -r "$TMP_FILT_BAM_FILE" - | \
				samtools view -F 1804 -f 2 -u - | \
				samtools sort - "$FILT_BAM_PREFIX" 

			sys rm -f "$TMP_FILT_BAM_FILE"
		}

		wait

		task( taskName := "alignPostprocessPE (rm dup)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			 FINAL_BAM_FILE <- FILT_BAM_FILE ) {

			sys $PRELOAD

			//# =============
			//# Mark duplicates
			//# =============

			sys echo "Mark duplicates"

			sys java $JVM_OPTS -jar ${PICARDROOT}/picard.jar MarkDuplicates \
				INPUT="$FILT_BAM_FILE" OUTPUT="$TMP_FILT_BAM_FILE2" \
				METRICS_FILE="$DUP_FILE_QC" VALIDATION_STRINGENCY=LENIENT \
				ASSUME_SORTED=true REMOVE_DUPLICATES=false

			//sys mv "$TMP_FILT_BAM_FILE2" "$FILT_BAM_FILE"

			//# ============================
			//# Remove duplicates
			//# Index final position sorted BAM
			//# Create final name sorted BAM
			//# ============================

			sys echo "Remove duplicates"

			//sys samtools view -F 1804 -f 2 -b "$FILT_BAM_FILE" > "$FINAL_BAM_FILE"
			sys samtools view -F 1804 -f 2 -b "$TMP_FILT_BAM_FILE2" > "$FINAL_BAM_FILE"
		}

		wait

		task( taskName := "alignPostprocessPE (sort final bam)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			FINAL_NMSRT_BAM_FILE <- FINAL_BAM_FILE ) {

			sys $PRELOAD

			sys samtools sort -n "$FINAL_BAM_FILE" "$FINAL_NMSRT_BAM_PREFIX"
		}

		task( taskName := "alignPostprocessPE (index final bam)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS]  <- FINAL_BAM_FILE ) {

			sys $PRELOAD

			//# Index Final BAM file

			sys samtools index "$FINAL_BAM_FILE"

			sys mv -f "$FINAL_BAM_FILE".bai "$FINAL_BAM_INDEX_FILE"
			sys samtools flagstat "$FINAL_BAM_FILE" > "$FINAL_BAM_FILE_MAPSTATS"
		}

		task( taskName := "alignPostprocessPE (QC final bam)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			PBC_FILE_QC <- TMP_FILT_BAM_FILE2 ) {

			sys $PRELOAD

			//# =============================
			//# Compute library complexity
			//# =============================
			//# Sort by name
			//# convert to bedPE and obtain fragment coordinates
			//# sort by position and strand
			//# Obtain unique count statistics

			sys echo "Compute library complexity"

			//# TotalReadPairs [tab] DistinctReadPairs [tab] OneReadPair [tab] TwoReadPairs [tab] NRF=Distinct/Total [tab] PBC1=OnePair/Distinct [tab] PBC2=OnePair/TwoPair
			//sys samtools sort -n -o "$FILE_BAM_FILE" "$FILT_BAM_FILE.tmp" | \
			sys samtools sort -n -o "$TMP_FILT_BAM_FILE2" "$TMP_FILT_BAM_FILE2.tmp" | \
				bedtools bamtobed -bedpe -i stdin | \
				awk 'BEGIN{OFS="\t"}{print $1,$2,$4,$6,$9,$10}' | \
				grep -v 'chrM' | sort | uniq -c | \
				awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > "$PBC_FILE_QC"

			sys rm -f $FILT_BAM_FILE
			sys rm -f $TMP_FILT_BAM_FILE2
		}
	}

	//# sort the raw bam file
	SORTED_BAM_FILE := RAW_BAM_FILE.replace(".bam",".sort.bam")
	SORTED_BAM_IDX_FILE := SORTED_BAM_FILE + ".bai"

	task( taskName := "sort bam (V-plot)", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 [SORTED_BAM_FILE, SORTED_BAM_IDX_FILE] <- RAW_BAM_FILE ) {

		sys $PRELOAD

		sys cd $OUTPUT_DIR

		//# preseq needs sorted input
		sys samtools sort -Ttmp -l0 -Obam "$RAW_BAM_FILE" -o "$SORTED_BAM_FILE"

		sys samtools index "$SORTED_BAM_FILE"
	}

	wait

	PRESEQ_FILE := SORTED_BAM_FILE + ".preseq.pdf"
	PRESEQ_GNU := OUTPUT_DIR + "/preseq.gnu"

	task( taskName := "PRESEQ", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 PRESEQ_FILE <- SORTED_BAM_FILE ) {

		sys $PRELOAD
		sys cd $OUTPUT_DIR

		sys echo "PRESEQ Analysis..."

		//# run preseq
		sys preseqData="$SORTED_BAM_FILE.preseq.dat"
		sys preseq lc_extrap -P -B -o "${preseqData}" "$SORTED_BAM_FILE" -v 2> "$SORTED_BAM_FILE.preseq.log"

		//# plot the results
		//# maximum number of reads on x axis in plot (in millions)
		sys XMAX=500

		sys titleName=$(basename $SORTED_BAM_FILE)
		sys titleName=${titleName//_/\\_ } #escape underscores

		sys echo "set terminal pdfcairo" > $PRESEQ_GNU
		sys echo "set output '$SORTED_BAM_FILE.preseq.pdf'" >> $PRESEQ_GNU
		sys echo "set key box bottom right" >> $PRESEQ_GNU
		sys echo "set style line 1 linewidth 5" >> $PRESEQ_GNU
		sys echo "set style line 2 linewidth 1" >> $PRESEQ_GNU
		sys echo "set mxtics 2" >> $PRESEQ_GNU
		sys echo "set grid ytics xtics mxtics" >> $PRESEQ_GNU
		sys echo "set xrange [0:${XMAX}]" >> $PRESEQ_GNU
		sys echo "set xlabel \"Number of Reads [millions]\"" >> $PRESEQ_GNU
		sys echo "set ylabel \"Expected Distinct Reads [millions]\"" >> $PRESEQ_GNU
		sys echo "set title \"PRESEQ Results for ${titleName}\"" >> $PRESEQ_GNU
		sys echo "plot '${preseqData}' using (\$1/1000000):(\$2/1000000) with lines linestyle 1 notitle, '' using (\$1/1000000):(\$3/1000000) with lines linestyle 2 notitle, '' using (\$1/1000000):(\$4/1000000) with lines linestyle 2 title '+/- 95% confidence interval' " >> $PRESEQ_GNU

		sys gnuplot $PRESEQ_GNU
	}

	wait

	print( "\nalignPostprocessATAC...\n" )

	input_bam 	:= FINAL_BAM_FILE
	mitoBAM 	:= input_bam.replace(".bam",".chrM.bam")
	nonMitoBAM 	:= input_bam.replace(".bam",".nonchrM.bam")
	nonMitoBAM_hist_graph := "$nonMitoBAM.hist_graph.pdf"

	output_file := nonMitoBAM.replace(".bam",".tn5.bed.gz")

	task( taskName := "alignPostprocessATAC", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 [output_file, mitoBAM, nonMitoBAM, nonMitoBAM_hist_graph] <- input_bam ) {

		sys $PRELOAD

		sys nonMitoChromosomes=$(samtools view -H "$input_bam" | \
								grep chr | cut -f2 | sed 's/SN://g' | grep -v chrM)

		sys samtools view -b "$input_bam" ${nonMitoChromosomes} > "$nonMitoBAM"
		
		sys samtools view -b "$input_bam" chrM > "$mitoBAM"

		//# Process only non chrM reads
		// embedded adjustBedTn5.sh	
		sys bamToBed -i "$nonMitoBAM" | \
			awk -F $'\t' 'BEGIN {OFS = FS}{ if ($6 == "+") {$2 = $2 + 4} else if ($6 == "-") {$3 = $3 - 5} print $0}' | \
			gzip -c > "$output_file"

		sys java $JVM_OPTS -jar ${PICARDROOT}/picard.jar CollectInsertSizeMetrics \
			INPUT="$nonMitoBAM" OUTPUT="$nonMitoBAM.hist_data.log" \
			H="$nonMitoBAM_hist_graph" W=1000 STOP_AFTER=5000000
	}

	wait


	print( "\ncallATACpeaks...\n" )

	readBed 	:= output_file
	peakFile 	:= readBed.replace(".bed.gz",".pf"); //"$readBed.pf"

	task( taskName := "callATACpeaks", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 ["$peakFile.fc.signal.bigwig", "$peakFile.pval.signal.bigwig"] <- readBed ) {

		sys $PRELOAD

		sys adjustedBed="slopBed -i $readBed -g $CHROMSIZE -l 75 -r -75 -s"
		sys macs2 callpeak \
			-t <(${adjustedBed}) -f BED -n "$peakFile" -g "$GENOMESIZE" -p 1e-2 \
			--nomodel --shift "$fragLen" -B --SPMR --keep-dup all --call-summits

		sys macs2 bdgcmp \
			-t "$peakFile"_treat_pileup.bdg -c "$peakFile"_control_lambda.bdg \
			--o-prefix "$peakFile" -m FE
		sys slopBed -i "$peakFile"_FE.bdg -g "$CHROMSIZE" -b 0 | \
			bedClip stdin "$CHROMSIZE" "$peakFile.fc.signal.bedgraph"
		sys rm -f "$peakFile"_FE.bdg
		sys bedGraphToBigWig "$peakFile.fc.signal.bedgraph" "$CHROMSIZE" "$peakFile.fc.signal.bigwig"
		sys rm -f "$peakFile.fc.signal.bedgraph"

		//# sval counts the number of tags per million in the (compressed) BED file
		sys sval=$(wc -l <(zcat -f "$readBed") | awk '{printf "%f", $1/1000000}')
		sys macs2 bdgcmp \
			-t "$peakFile"_treat_pileup.bdg -c "$peakFile"_control_lambda.bdg \
			--o-prefix "$peakFile" -m ppois -S "${sval}"
		sys slopBed -i "$peakFile"_ppois.bdg -g "$CHROMSIZE" -b 0 | \
			bedClip stdin "$CHROMSIZE" "$peakFile.pval.signal.bedgraph"
		sys rm -f "$peakFile"_ppois.bdg
		sys bedGraphToBigWig "$peakFile.pval.signal.bedgraph" "$CHROMSIZE" "$peakFile.pval.signal.bigwig"
		sys rm -f "$peakFile.pval.signal.bedgraph"
	}	

	wait

	print( "\nMake VPlot...\n" )

	VPLOT_FILE := SORTED_BAM_FILE + "." + V_INDEX.baseName() + ".vect.png"

	task( taskName := "makeVPlot", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		 VPLOT_FILE <- [SORTED_BAM_FILE, V_INDEX] ) {

		sys $PRELOAD
		sys cd $OUTPUT_DIR

		//# generate V plot
		sys echo "Generating V Plot..."

		//# this script must be in PATH (didn't work with 20 thread, so reduce it to 4)
		sys python $(which $MAKE_VPLOT) -a "$SORTED_BAM_FILE" -b "$V_INDEX" -e 2000 -p ends -c 4 -v -u
	}

	wait

	print( "\nMake Report...\n" )

	TEX_FILE := "$OUTPUT_DIR/report.tex"
	PDF_FILE := "$OUTPUT_DIR/report.pdf"

	task( taskName := "make Report", cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
		[TEX_FILE, PDF_FILE] <- [nonMitoBAM_hist_graph, VPLOT_FILE, PRESEQ_FILE] ) {
		sys $PRELOAD

		sys cd $OUTPUT_DIR
		sys thisFolder=$OUTPUT_DIR

		//# figure out what we've aligned to
		sys MODEL=$BOWTIE_IDX

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys alignLog="$(echo *.align.log)"
		sys alignLogLastLine=$(tail -n 1 ${alignLog})

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys dupQCFile=$(echo *.dup.qc)
		sys dupQCHeadings=$(sed -n 7p ${dupQCFile})
		sys dupQCHeadings=${dupQCHeadings//_/\\\\_} #moar reformatting
		sys IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"

		sys dupQCData=$(sed -n 8p ${dupQCFile})
		sys IFS=$'\t' read -a dupQCData <<< "${dupQCData}"

		sys START=0
		sys END=${#dupQCHeadings[@]}
		sys DUPTABLE=""

		//## here we build up the tex styled table contents
		sys for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done

		//# library complexity data file name
		sys bpcQCFile=$(echo *.pbc.qc)

		//# library complexity data file contents
		sys declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair")
		sys bpcQC=$(cat ${bpcQCFile})
		sys IFS=$'\t' read -a bpcData <<< "${bpcQC}"

		sys START=0
		sys END=${#bpcLabels[@]}
		sys BPCTABLE=""

		//## here we build up the tex styled table contents
		sys for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done			

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $TEX_FILE
		sys echo "\usepackage{graphicx}" >> $TEX_FILE
		sys echo "\usepackage{multicol}" >> $TEX_FILE
		sys echo "\usepackage{listings}" >> $TEX_FILE
		sys echo "\usepackage{grffile}" >> $TEX_FILE
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $TEX_FILE
		sys echo "\usepackage{booktabs}" >> $TEX_FILE
		sys echo "\usepackage{hyphenat}" >> $TEX_FILE
		sys echo "\usepackage{fancyhdr}" >> $TEX_FILE
		sys echo "\pagestyle{fancy}" >> $TEX_FILE
		sys echo "\fancyhf{}" >> $TEX_FILE
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $TEX_FILE
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $TEX_FILE
		sys echo "\begin{document}" >> $TEX_FILE
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $TEX_FILE
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $TEX_FILE
		sys echo "\begin{multicols}{2}" >> $TEX_FILE
		sys echo "\subsection{Genome Model}" >> $TEX_FILE
		sys echo "${MODEL//_/\\_}" >> $TEX_FILE
		sys echo "\subsection{V-Plot}" >> $TEX_FILE
		sys echo "From ${vPlot//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $TEX_FILE
		sys echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $TEX_FILE
		sys echo "From ${preseqGraph//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $TEX_FILE
		sys echo "\subsection{Library Complexity}" >> $TEX_FILE
		sys echo "From ${bpcQCFile//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\centerline{" >> $TEX_FILE
		sys echo "\begin{tabular}{l|c}" >> $TEX_FILE
		sys echo "\toprule" >> $TEX_FILE
		sys echo "${BPCTABLE}" >> $TEX_FILE
		sys echo "\end{tabular}" >> $TEX_FILE
		sys echo "}" >> $TEX_FILE
		sys echo "\subsection{Insert size histogram}" >> $TEX_FILE
		sys echo "From ${insertSizeHist//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $TEX_FILE
		sys echo "\subsection{Picard Duplication Metrics}" >> $TEX_FILE
		sys echo "From ${dupQCFile//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\begin{tabular}{l|c}" >> $TEX_FILE
		sys echo "\toprule" >> $TEX_FILE
		sys echo "${DUPTABLE}" >> $TEX_FILE
		sys echo "\end{tabular}" >> $TEX_FILE
		sys echo "\subsection{bowtie2 Alignment Log}" >> $TEX_FILE
		sys echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $TEX_FILE
		sys echo "From ${alignLog//_/\\_}:\\\\" >> $TEX_FILE
		sys echo "\scalebox{.6}{" >> $TEX_FILE
		sys echo "\lstinputlisting{${alignLog}}" >> $TEX_FILE
		sys echo "}" >> $TEX_FILE
		sys echo "\end{multicols}  " >> $TEX_FILE
		sys echo "%\pagebreak" >> $TEX_FILE
		sys echo "\end{document}" >> $TEX_FILE		

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $OUTPUT_DIR
		sys pdflatex $TEX_FILE
	}

	wait
}





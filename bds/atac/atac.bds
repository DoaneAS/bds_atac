#!/usr/bin/env bds

include "../chipseq/modules/fastq.bds"
include "../chipseq/modules/bam.bds"
include "../chipseq/modules/tagalign.bds"
include "../modules/align_etc.bds"
include "../modules/align_bowtie2.bds"
include "../modules/preseq.bds"
include "../chipseq/modules/peakcall_macs2.bds"
include "../chipseq/modules/report.bds"


help ATAC-Seq Pipeline setting
input 		:= ""		help Input file type (automatically determined if not specified) (default: blank).

trimmed_fastq 	:= false	help Add it to skip fastq-trimming stage (default: false).
fraglen 	:= 75 		help Read fragment length (default: 75).
num_rep 	:= 1		help # replicates. ATAC seq for each replicate will go IN PARALLEL. (default: 1).

mapping	 	:= false	help Add it to perform mapping only (no MACS2 peak.
vplot 		:= false 	help Add it to create V plot (default: false).
preseq 		:= false 	help Add it to perform preseq analysis (default: false).
make_tag 	:= false 	help Add it to create tagalign and pseudo replicates for it (default: false).


help()

init_atac()

chk_input_data()

set_shell_env()

atac()



void init_atac() {

	if ( conf_file_exists() ) {

		input 		= get_conf_val( input, 			["input_type", "input"] )
		trimmed_fastq 	= get_conf_val_bool( trimmed_fastq,	["trimmed_fastq"] )
		fraglen 	= get_conf_val_int( fraglen,		["fraglen", "frag_len"] )
		num_rep 	= get_conf_val_int( num_rep,		["num_rep", "numrep"] )

		mapping		= get_conf_val_bool( mapping,		["mapping"] )

		vplot 		= get_conf_val_bool( vplot,		["vplot"] )
		preseq 		= get_conf_val_bool( preseq,		["preseq"] )
		make_tag	= get_conf_val_bool( make_tag,		["make_tag"] )
	}
	else if ( is_legacy_input() ) { // legacy input method taking first 8 parameters from cmd. line (num_rep=1)

		bwt2_idx 	= args[0].trim()
		fastq1_1	= args[1].trim()
		fastq1_2	= args[2].trim()
		nth_bwt2	= args[3].trim().parseInt()
		gensz		= args[4].trim()
		chrsz		= args[5].trim()
		vplot_idx 	= args[6].trim()
		out_dir 	= args[7].trim()

		vplot 		= true
		preseq 		= true

		mapping 	= false
	
		if ( v ) { // verbose
			print("\n\n")
			print("Legacy input method found (8 parameters)\n")
			print("========================================\n")
			print( "Bowtie2 index\t\t: $bwt2_idx\n" )
			print( "Read 1\t\t\t: $fastq1_1\n" )
			print( "Read 2\t\t\t: $fastq1_2\n" )
			print( "# threads (bowtie2)\t: $nth_bwt2\n")
			print( "Genome size (hs,mm)\t: $gensz\n" )
			print( "Chromosome sizes file\t: $chrsz\n" )
			print( "V-Plot index\t\t: $vplot_idx\n" )
			print( "Output dir.\t\t: $out_dir\n" )
		}

		num_rep = 1
	}


	if ( input == "" ) {  // determine input type if input is not defined
		if ( get_bam(0,1) != "" ) 	input = "bam"
		if ( get_fastq(0,1,1) != "" ) 	input = "fastq"
	}

	if ( v ) { // verbose
		print("\n")
		print( "Input data type\t\t: $input\n")		
		print( "Fastqs are trimmed?\t: $trimmed_fastq\n")
		print( "Fragment length\t\t: $fraglen\n")
		print( "# Replicates\t\t: $num_rep\n")
		print( "Vplot generation\t: $vplot\n")
		print( "Preseq analysis\t\t: $preseq\n")
		print( "Tagalign generation\t: $make_tag\n")
		print( "MACS2 peak calling\t: " + !mapping + "\n")
	}
}

void chk_input_data() {

	if ( is_input_fastq() && !path_exists("$bwt2_idx.1.bt2") ) error("\nBowtie2 index doesn't exists! ($bwt2_idx.1.bt2)\n")

	if ( vplot && !path_exists( vplot_idx ) ) error("\nVPlot index doesn't exists! ($vplot_idx) \n")	

	if ( !mapping && !path_exists( chrsz ) ) error("\nChromosome sizes file doesn't exists! ($chrsz)\n")	

	print("\n")

	if ( is_input_fastq() ) {

		string[] fastqs_all

		for ( int rep=1; rep <= num_rep; rep++) {

			string read1, read2

			fastqs := get_fastqs( 0, rep )

			if ( fastqs.size()==0 ) error("No fastq defined for replicate $rep\n")

			if ( (num_rep==1) && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

			prefix := "Rep$rep fastq"
			print("$prefix :\n")

			for ( string s : fastqs ) {
				print("\t$s\n")
				if ( (s != "") && !path_exists(s) ) error("\t\tFile not found!\n")
			}

			// check any duplicate input filename
			for ( string s : fastqs ) {
				if ( is_in_array( get_basename( s ), get_basename( fastqs_all ) ) ) \
					error( "\tFilename is duplicate for $prefix!\n")
			}

			fastqs_all = concat( fastqs_all, fastqs )
		}
	}
	else {
		string[] bams_all

		for ( int rep=1; rep <= num_rep; rep++) {

			bam := get_bam( 0, rep )

			if ( bam == "" ) error("No bam defined for replicate $rep\n")

			prefix := "Rep$rep bam"
			print("$prefix :\n")

			print("\t$bam\n")
			if ( !path_exists(bam) ) error("\t\tFile not found!\n")

			// check any duplicate input filename
			if ( is_in_array( get_basename( bam ), get_basename( bams_all ) ) ) \
				error( "\tFilename is duplicate for $prefix!\n")

			bams_all.add( bam )
		}
	}
}

void atac() {

	for (int rep=1; rep<=num_rep; rep++) {
		if ( no_par_job ) {
			_atac( rep )
		}
		else {
			par _atac( rep )
		}
	}

	wait
}

void _atac( int rep ) {

	info := get_task_info( 0, rep ) // no info needed for atac

	atac_out_dir := mkdir_path( (num_rep==1) ? out_dir : "$out_dir/$info" )

	string bam, nodup_bam

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )
		if ( (num_rep==1) && (fastqs.size()<2) ) fastqs.add( get_fastq( 0, 2, 1 ) )

		string p1, p2

		if ( trimmed_fastq ) {
			print("\nSkipping trimming fastqs (-trimmed_fastq flag is on)\n\n")

			p1 = fastqs[0]
			p2 = fastqs[1]
		}
		else {
			( p1, p2 ) = _trim_adapters( fastqs[0], fastqs[1], atac_out_dir, info )
		}

		wait // hold parallel

		bam = _bowtie2( p1, p2, atac_out_dir, info )

		wait

		nodup_bam = _bam_to_nodup_bam_PE( bam, atac_out_dir, info )

	}
	else {
		bam = get_bam( 0, rep )
		nodup_bam = bam
	}

	wait

	if ( make_tag ) {
		tag := _bam_to_tag( nodup_bam, atac_out_dir, info )

		wait

		_spr( tag, atac_out_dir, info )

		if ( no_par_job ) wait
	}

	bed := _bam_to_bed_non_chrM( nodup_bam, atac_out_dir, info )

	wait

	if ( !mapping ) {
		_macs2_bed( bed, "$fraglen", atac_out_dir, info )

		if ( no_par_job ) wait
	}

	string srt_bam

	if ( vplot || preseq ) srt_bam = _bam_to_srt_bam( bam, atac_out_dir, info )

	wait

	string png, pdf

	if ( vplot ) {
		png = _vplot( srt_bam, atac_out_dir, info )

		if ( no_par_job ) wait
	}

	if ( preseq ) {
		pdf = _preseq( srt_bam, atac_out_dir, info )
	}

	wait

	_report_atac( pdf, png, atac_out_dir, info )
}

string[] _report_atac( string pdf, string png, string out_dir, string info ) {

	tex_file := "$out_dir/report.tex"
	pdf_file := "$out_dir/report.pdf"

	// a lot of inputs so I picked up just two
	in 	:= [pdf, png]
	out 	:= [tex_file, pdf_file]

	task( taskName:= "report "+info, \
		cpus:=nth, mem:=parse_mem_or_skip(memory), timeout:=parse_time_or_skip(wt), \
		out<-in ) {

		sys $SHCMD_INIT

		sys cd $out_dir
		sys thisFolder=$out_dir

		//# figure out what we've aligned to
		sys MODEL=$bwt_idx

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys if [[ $input == "fastq" ]]; then \
			alignLog="$(echo *.align.log)"; \
			alignLogLastLine=$(tail -n 1 ${alignLog}); \
			fi

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys if [[ $input == "fastq" ]]; then \
			dupQCFile=$(echo *.dup.qc); \
			dupQCHeadings=$(sed -n 7p ${dupQCFile}); \
			dupQCHeadings=${dupQCHeadings//_/\\\\_}; \
			IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"; \
			dupQCData=$(sed -n 8p ${dupQCFile}); \
			IFS=$'\t' read -a dupQCData <<< "${dupQCData}"; \
			START=0; \
			END=${#dupQCHeadings[@]}; \
			DUPTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			bpcQCFile=$(echo *.pbc.qc); \
			declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair"); \
			bpcQC=$(cat ${bpcQCFile}); \
			IFS=$'\t' read -a bpcData <<< "${bpcQC}"; \
			START=0; \
			END=${#bpcLabels[@]}; \
			BPCTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			fi

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $tex_file
		sys echo "\usepackage{graphicx}" >> $tex_file
		sys echo "\usepackage{multicol}" >> $tex_file
		sys echo "\usepackage{listings}" >> $tex_file
		sys echo "\usepackage{grffile}" >> $tex_file
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $tex_file
		sys echo "\usepackage{booktabs}" >> $tex_file
		sys echo "\usepackage{hyphenat}" >> $tex_file
		sys echo "\usepackage{fancyhdr}" >> $tex_file
		sys echo "\pagestyle{fancy}" >> $tex_file
		sys echo "\fancyhf{}" >> $tex_file
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $tex_file
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $tex_file
		sys echo "\begin{document}" >> $tex_file
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $tex_file
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $tex_file
		sys echo "\begin{multicols}{2}" >> $tex_file
		sys echo "\subsection{Genome Model}" >> $tex_file
		sys echo "${MODEL//_/\\_}" >> $tex_file

		sys if [[ $vplot == "true" ]]; then \
			echo "\subsection{V-Plot}" >> $tex_file; \
			echo "From ${vPlot//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $tex_file; \
			fi

		sys if [[ $preseq == "true" ]]; then \
			echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $tex_file; \
			echo "From ${preseqGraph//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $tex_file; \
			fi

		sys if [[ $input == "fastq" ]]; then \
			echo "\subsection{Library Complexity}" >> $tex_file; \
			echo "From ${bpcQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\centerline{" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${BPCTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "}" >> $tex_file; \
			echo "\subsection{Insert size histogram}" >> $tex_file; \
			echo "From ${insertSizeHist//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $tex_file; \
			echo "\subsection{Picard Duplication Metrics}" >> $tex_file; \
			echo "From ${dupQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${DUPTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "\subsection{bowtie2 Alignment Log}" >> $tex_file; \
			echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $tex_file; \
			echo "From ${alignLog//_/\\_}:\\\\" >> $tex_file; \
			echo "\scalebox{.6}{" >> $tex_file; \
			echo "\lstinputlisting{${alignLog}}" >> $tex_file; \
			fi

		sys echo "}" >> $tex_file
		sys echo "\end{multicols}  " >> $tex_file
		sys echo "%\pagebreak" >> $tex_file
		sys echo "\end{document}" >> $tex_file		

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $out_dir
		sys pdflatex $tex_file
	}

	return out
}

void set_shell_env() {
	
	// create output dir.	

	if ( is_kundaje_lab() || is_scg3() ) {

		print("\n\nAutomatically adding environment variables... (kundaje_lab: $hostname) \n\n")

		if ( SHCMD_INIT.indexOf( init_mod ) < 0  ) { // if not module init. cmd found, then add it
			SHCMD_INIT = SHCMD_INIT + " . /etc/profile.d/modules.sh;"
		}

		if ( is_scg3() ) { // if on SCG3		
			SHCMD_INIT = SHCMD_INIT + " module add gnuplot/5.0 python/2.7.6;" \
		}

		SHCMD_INIT = SHCMD_INIT + " module add bowtie/2.2.4 samtools/1.2 bedtools/2.21.0;" \
					+ " module add picard-tools/1.129 ucsc_tools/3.0.9 MACS2/2.1.0 java/latest;" \
					+ " module add preseq/1.0.2 texlive/2013;" \
					+ " export _JAVA_OPTIONS='-Xms256M -Xmx2048M -XX:ParallelGCThreads=1'; export MAX_JAVA_MEM='16G'; export MALLOC_ARENA_MAX=4"
		SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )

		if ( v ) { // verbose
			print( "Final shell cmd. for init.\t: $SHCMD_INIT\n" )
		}
	}
}

void help() {

	if ( is_cmd_line_arg_empty() ) {

		print("\n")
		print(" Usage 1 (command line argument, legacy input method): \n")
		print("\n")
		print("\t\$ bds atac.bds [BOWTIE_INDEX] [READ1] [READ2] [NTHREADS_BWT2] [GENOMESIZE] [CHROMSIZES] [VPLOT_INDEX] [OUTPUT_DIR] \n")
		print("\n")
		print(" Usage 2 (command line argument): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -fastq1 [READ1] \\ \n")
		print("\t\t -fastq2 [READ2] \\ \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\n")
		print("\tIf you want V plot generation add the following:\n")
		print("\t\t -vplot -vplot_idx [VPLOT_INDEX]\n")
		print("\n")
		print("\tIf you want preseq analysis add the following:\n")
		print("\t\t -preseq\n")
		print("\n")
		print("\tIf you don't want MACS2 peak calling add the following:\n")
		print("\t\t -mapping\n")
		print("\n")
		print(" Usage 3 (configruation file): \n")
		print("\n")
		print("\t\$ bds atac.bds [CONF_FILE]\n")
		print("\n")
		print("\t=== [CONF_FILE] contents ===\n")
		print("\tbwa_idx= [BOWTIE_INDEX]\n")
		print("\tfastq1= [READ1]\n")
		print("\tfastq2= [READ2]\n")
		print("\tnth_bwt2= [NTHREADS_BWT2]\n")
		print("\tgensz= [GENOMESIZE]\n")
		print("\tchrsz= [CHROMSIZES]\n")
		print("\tout_dir= [OUTPUT_DIR]\n")
		print("\tvplot= [NEED_VPLOT_GENERATION]\n")
		print("\tvplot_idx= [VPLOT_INDEX]\n")
		print("\tpreseq= [NEED_PRESEQ_ANALYSIS]\n")
		print("\n")
		print(" Usage 4 (command line argument, multiple replicates): \n")
		print("\n")
		print("\t\$ bds atac.bds -bwt_idx [BOWTIE_INDEX] \\ \n")
		print("\t\t -rep_num [NUMBER_OF_REPLICATES] \\ \n")
		print("\t\t -fastq1_1 [REP1_READ1] \\ \n")
		print("\t\t -fastq1_2 [REP1_READ2] \\ \n")
		print("\t\t -fastq2_1 [REP2_READ1] \\ \n")
		print("\t\t -fastq2_2 [REP2_READ2] \\ \n")
		print("\t\t ... \n")
		print("\t\t -nth_bwt2 [NTHREADS_BWT2] \\ \n")
		print("\t\t -gensz [GENOMESIZE] \\ \n")
		print("\t\t -chrsz [CHROMSIZES] \\ \n")
		print("\t\t -out_dir [OUTPUT_DIR] \n")
		print("\t\t -vplot -vplot_idx [VPLOT_INDEX] \\ \n")
		print("\t\t -preseq \\ \n")
		print("\n")
		print(" For Sun Grid Engine (SGE) cluster use\n")
		print("\n")
		print("\t\$ bds -s sge atac.bds ... \n")
		print("\n")
		print(" List of parameters\n")
		print(" \n")
		printHelp()

		exit
	}
}

string get_task_info( int ctl, int rep ) {

	return ( (ctl>0) ? "ctl_" : "") + "rep" + rep
}

bool is_legacy_input() {

	bool ret

	if ( args.size() >= 8 ) {
		ret = true

		for (int i=0; i<8;i++) {
			
			if ( args[i].startsWith("-") ) {
				ret = false
				break
			}
		}
	}

	return ret
}

bool is_input_fastq() {

	return input.toLower() == "fastq"
}

bool is_input_bam() {

	return input.toLower() == "bam"
}

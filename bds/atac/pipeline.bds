#!/usr/bin/env bds

helpUnsorted := true // help will not be sorted

// cmd line arg. wrapper
string c 		= "" 			help Configuration file path (if not specified, define parameters in command line argument).

string prefix		= ""			help Prefix for all outputs.
string o 		= "out" 		help Output directory. (default: out)
string tmp 		= "tmp"			help Temporary directory for intermediate files. (default: tmp).
//string gen		= "" 			help Reference genome name for epigenome browser track generation (eg. hg19, hg18, mm9 or mm10)

bool no_par_job		= false			help Set if true to serialize all jobs, this option is for desktops with limited memory (default: false)
int wt 			= 10800			help Default walltime in seconds for all cluster jobs (default: 10800).
int nth			= 1 			help Default number of threads for all cluster jobs (default: 1).
int mem 		= 4000			help Default max. memory in MB for all cluster jobs (default: 4000).

string mod 		= ""			help Modules separated by ; (example: "bowtie/2.2.4; bwa/0.7.7; picard-tools/1.92").
string shcmd 		= ""			help Shell cmds separated by ;. Env. vars should be written as ${VAR} not as $VAR (example: "export PATH=${PATH}:/usr/test; VAR=test"). 
string addpath 		= "" 			help Path to be PREPENDED to env. var. PATH. Multiple paths should be separated by ; (example: "/bin/test:/bin/test2")

// parameters
string CONF_FILE 	= c
string PREFIX 		= prefix
string OUTPUT_DIR 	= o
string TMP_DIR 		= tmp
//string REF_GENOME	= gen

bool NO_PARALLEL_JOB	= no_par_job
int WALLTIME 		= wt
int NTHREADS 		= nth
int MEMORY 		= mem
string MODULE 		= mod
string SHELLCMD		= shcmd
string ADDPATH 		= addpath


// find BDS script path (path of BDS script will be automatically added to env. var. ${PATH})
string SCRIPT_FILE 	= "$ppwd/$programPath" 	// path of your BDS script
if (!SCRIPT_FILE.exists()) SCRIPT_FILE = "$programPath"
string SCRIPT_PATH	= SCRIPT_FILE.dirName() // dir of your BDS script

// system parameters
string{} conf 		// config. file
string DIR_SW_BDS 		= "$HOME/software_bds"
string INIT_MOD 		= "/etc/profile.d/modules.sh"
string PRELOAD 			= ""
string PRELOAD_MODULE_HEADER 	= ". $INIT_MOD;"
string PRELOAD_MODULE 		= ""
string PRELOAD_SHELLCMD_HEADER 	= "export PATH=\"\${PATH}:/bin:/usr/bin:$SCRIPT_PATH:\${HOME}/.bds\";" // default path for basic linux utils
string PRELOAD_SHELLCMD 	= ""
string HTML_REPORT

void read_param_general() {

	// if only one argument, it must be configuration file
	if ( args.size()==1  ) {
		CONF_FILE=args[0]
	}

	if ( cmd_line_arg_is_empty() ) {
		error( "No parameters are given (cmd. line arguments or configuration file (-c $CONF_FILE).\n")

	}
	if ( conf_file_exists() ) { // parameters in conf_file overrides those on cmd line args.

		conf = config(CONF_FILE)

		if ( conf.hasKey("PREFIX") ) 		PREFIX 		= chk_slash( conf{ "PREFIX" } )

		if ( conf.hasKey("OUTPUT_DIR") ) 	OUTPUT_DIR	= rm_comment( conf{ "OUTPUT_DIR" } ) 

		if ( conf.hasKey("TMP_DIR") ) 		TMP_DIR 	= rm_comment( conf{ "TMP_DIR" } )

		if ( conf.hasKey("NO_PARALLEL_JOB") )	NO_PARALLEL_JOB	= parse_bool( conf{ "NO_PARALLEL_JOB"} )
		if ( conf.hasKey("WALLTIME") ) 		WALLTIME 	= parse_int( conf{ "WALLTIME" } ) 
		if ( conf.hasKey("NTHREADS") ) 		NTHREADS  	= parse_int( conf{ "NTHREADS" } ) 
		if ( conf.hasKey("MEMORY") ) 		MEMORY 		= parse_int( conf{ "MEMORY" } ) 

		//if ( conf.hasKey("REF_GENOME") )	REF_GENOME	= rm_comment( conf{ "REF_GENOME" } ) 

		for( string k : conf.keys() ) {
			// if key is comment ignore
			if ( k.indexOf("//")>=0 ) \
				continue

			// concat. module
			if ( k.indexOf("MODULE")>=0 ) {

				trimmed := rm_comment( conf{k} )
				trimmed = trimmed.replace("module add ","")
				mods := trimmed.split(";")

				for ( string str : mods ) \
					PRELOAD_MODULE = PRELOAD_MODULE + " module add " + str.trim() + ";"
			}
			else if ( k.indexOf("SHELLCMD")>=0 ) {

				trimmed := rm_comment( conf{k} )			
				PRELOAD_SHELLCMD = PRELOAD_SHELLCMD + " " + trimmed + ";"
			}
			else if ( k.indexOf("ADDPATH")>=0 ) {

				trimmed := rm_comment( conf{k} )

				trimmed = trimmed.replace(":",";")
				paths := trimmed.split(";")

				PATH := " export PATH=\${PATH}"

				for ( string str : paths ) \
					PATH = PATH + ":" + str.trim()

				PRELOAD_SHELLCMD = PRELOAD_SHELLCMD + PATH + ";"
			}
		}
	} 

	OUTPUT_DIR 	= mkdir_path( OUTPUT_DIR )
	TMP_DIR 	= mkdir_path( TMP_DIR )

	if ( MODULE!="" ) {
		if ( INIT_MOD.exists() ) { // if /etc/profile.d/modules.sh exists

			trimmed := MODULE.trim()
			mods := trimmed.split(";")

			for ( string str : mods ) \
				PRELOAD_MODULE = PRELOAD_MODULE + " module add " + str.trim() + ";"
		}
	}

	if ( SHELLCMD!="" ) {
		trimmed := SHELLCMD.trim()		
		PRELOAD_SHELLCMD = PRELOAD_SHELLCMD + " " + trimmed + ";"
	}

	if ( ADDPATH!="" ) {
		trimmed := ADDPATH.trim()

		trimmed = trimmed.replace(":",";")
		paths := trimmed.split(";")
		//PATH := " export PATH=\${PATH}"
		//for ( string str : paths ) \
		//	PATH = PATH + ":" + str.trim()
		PATH := " export PATH="
		for ( string str : paths ) \
			PATH = PATH + str.trim() + ":"
		PATH = PATH + "\${PATH}"

		PRELOAD_SHELLCMD = PRELOAD_SHELLCMD + PATH + ";"
	}

	// check params
	if ( PREFIX=="") {
		error( "PREFIX is null, specify it.\n" )
	}	

	// print params
	print("CONF_FILE = $CONF_FILE\n");

	print("PREFIX = $PREFIX\n");
	print("OUTPUT_DIR = $OUTPUT_DIR\n");
	print("TMP_DIR = $TMP_DIR\n");

	//print("REF_GENOME = $REF_GENOME (for genome browser track generation)\n" );
	print("NO_PARALLEL_JOB = $NO_PARALLEL_JOB\n");
	print("WALLTIME = $WALLTIME (seconds)\n");
	print("NTHREADS = $NTHREADS\n");
	print("MEMORY = $MEMORY (megabytes)\n");

	// additional initialization
	PRELOAD = PRELOAD_SHELLCMD_HEADER + PRELOAD_SHELLCMD
	if ( PRELOAD_MODULE != "" ) \
		PRELOAD = PRELOAD + "; " + PRELOAD_MODULE_HEADER + PRELOAD_MODULE

	PRELOAD = PRELOAD.replace( ";;", ";" )

	print("PRELOAD = $PRELOAD (shell commands to be executed at the beginning of every tasks\n");

	HTML_REPORT = "$OUTPUT_DIR/Report.html"

	// generate reference genome file if defined
	//if ( REF_GENOME != "" ) \
	//	sys echo $REF_GENOME > "$OUTPUT_DIR/ref_genome.txt"
}


bool conf_file_exists() {

	if ( CONF_FILE=="" ) {
		return false
	}
	else {
		return CONF_FILE.exists()
	}
}


bool cmd_line_arg_is_empty() {

	return args.size()==0
}

bool cmd_line_arg_has_dash() {

	if ( !cmd_line_arg_is_empty() ) {
		if ( args[0].substr(0,1) == '-' ) {
			return true
		}
	}
	return false
}

// string functions


string chk_slash( string str ) { // if slash found, error
	trimmed := rm_comment( str )
	if ( trimmed.indexOf("/")>=0 ) {
		error("error: path including / not allowed for $str\n")
	}
	return trimmed
}

string chk_file( string str, string ext ) {
	path := get_path( str )
	path_ext := path + ext

	if ( !path_ext.exists() ) {
		error("error: file does not exist for $path_ext\n")
	}
	else if ( path_ext.isDir() ) {
		error("error: need file instead of dir for $path_ext\n")
	}
	else if ( path_ext.isFile() ) {
		return path
	}
	else {
		error("error: unknown error for $path_ext\n")
	}
}

string mkdir_path( string str ) { 
	// make filename full path and mkdir -p
	path := get_path( str )

	if ( path.exists() ) {		
		return path
	}
	else if ( path.mkdir() ) {
		return path
	}
	else {
		error("error: could not make for $path\n")
	}
}

string get_path( string str ) {
	base := rm_str_at_end( str, "/" ).path()
	return base
	//ret := (base.indexOf(ppwd)==0) ? base.replace(ppwd,".") : base
	//print("$base, $ppwd, $ret\n")
	//return ret
}

string rm_str_at_end( string str, string rm ) {
	trimmed := rm_comment( str )
	if ( trimmed.substr( trimmed.length()-rm.length() ) == rm ) { // if "/" exists at the end of the string
		return trimmed.substr( 0, trimmed.length()-rm.length() )
	}
	
	return trimmed
}

string rm_comment( string str ) { // remove substring after double slash "//"
	trimmed := str.trim()
	int pos = trimmed.indexOf("//")

    if ( pos>=0 ) {
		return trimmed.substr(0,pos-1).trim()
	}

	return trimmed
}

int parse_int( string str ) {
	return rm_comment( str ).parseInt()
}

bool parse_bool( string str ) {
	return rm_comment( str ).parseBool()
}

real parse_real( string str ) {
	return rm_comment( str ).parseReal()
}

int round( real f ) {
	string s = f
	arr := s.split('\.')
	int a = arr[0].parseInt()
	int b = arr[1].parseInt()
	if ( b >= 5 ) return a+1
	else return a
}

void write_report( string title ) {

	print("\n====== Generating reports (out: $HTML_REPORT) \n")

	html_header := 	"<html> <head> <title>"+ title+"</title> </head> <body> <h1>" + title + "</h1>\n"
	html_footer := "\n</body></html>\n"

	string[] report_contents

	report_contents.push( html_header )

	// recursively find all files for report (png, pdf, txt, qc, ccscores)
	write_files_to_report( OUTPUT_DIR, report_contents )

	report_contents.push( html_footer )

	HTML_REPORT.write( array_to_str( report_contents ) )
	//print( array_to_str( report_contents ) )
}

void write_files_to_report( string path, string[] lines ) {
	all := path.dirPath()	

	for ( string str : all ) {
		//print("debug: $str\n")
		if ( str.isDir() ) {
			write_files_to_report( str, lines )
		}
		else {	
			rel_path := str.replace( OUTPUT_DIR.path(), "." )

			string html = "<h2>" + rel_path + "</h2> \n"

			if ( str.endsWith( ".png") || str.endsWith( ".jpg") || str.endsWith( ".gif") ) {
				html = html + 	"<a href=" + rel_path + ">" + rel_path  + "</a>\n" + \
						"<img src=" + rel_path + ">\n"
			}
			else if ( str.endsWith( ".pdf") ||  str.endsWith( ".ps") ) {
				html = html + 	"<a href=" + rel_path + ">" + rel_path  + "</a>\n"
			} 
			else if ( str.endsWith( ".ccscores") || str.endsWith( ".cc.qc" ) ) {				
				html = html + 	"<pre>" + "Filename\tnumReads\testFragLen\tcorr_estFragLen\tPhantomPeak\tcorr_phantomPeak\targmin_corr\tmin_corr\tphantomPeakCoef\trelPhantomPeakCoef\tQualityTag<br>" + \
						array_to_str( str.readLines() ) + "</pre>\n"
						
				html = html + 	"<pre>" + \
						"Normalized strand cross-correlation coefficient (NSC) = col9 in outFile <br>" + \
						"Relative strand cross-correlation coefficient (RSC) = col10 in outFile <br>" + \
						"Estimated fragment length = col3 in outFile, take the top value <br>" + \
						"Important columns highlighted, but all/whole file can be stored for display <br>" + \
						 "</pre>\n"
						 
			}
			else if ( str.endsWith( ".pbc.qc" ) ) {
				html = html + "<pre>" + "TotalReadPairs\tDistinctReadPairs\tOneReadPair\tTwoReadPairs\tNRF=Distinct/Total\tPBC1=OnePair/Distinct\tPBC2=OnePair/TwoPair<br>" + \
						array_to_str( str.readLines() ) + "</pre>\n"
				html = html + "<pre>" + \
						"NRF (non redundant fraction) <br>" + \
						"PBC1 (PCR Bottleneck coefficient 1) <br>" + \
						"PBC2 (PCR Bottleneck coefficient 2) <br>" + \
						"PBC1 is the primary measure. Provisionally <br>" + \
						"<ul>" + \
						"<li>0-0.5 is severe bottlenecking</li>" + \
						"<li>0.5-0.8 is moderate bottlenecking </li>" + \
						"<li>0.8-0.9 is mild bottlenecking </li>" + \
						"<li>0.9-1.0 is no bottlenecking </li>" + \
						"</ul>" + \
						"</pre>\n"				
			}
			else if ( str.endsWith( ".txt") || str.endsWith( ".qc" )) {
				if ( str.size() > 1000000 ) { // if file size is too big > 1MB just link
					html = html + 	"<a href=" + rel_path + ">" + rel_path  + "</a>\n"
				}
				else {
					html = html + 	"<pre>" + array_to_str( str.readLines() ) + "</pre>\n"
				}
			}
			else {
				continue
			}

			lines.push( html )
		}
	}
}

string array_to_str( string[] arr ) {
	string ret
	for ( string str : arr ) ret = ret + str + "\n"	
	return ret
}

string[] concat( string[] s1, string[] s2 ) {
	string[] ret	
	for ( string str : s1 ) ret.push(str)
	for ( string str : s2 ) ret.push(str)
	return ret
}

string[] concat( string[] s1, string[] s2, string[] s3 ) {
	string[] ret	
	for ( string str : s1 ) ret.push(str)
	for ( string str : s2 ) ret.push(str)
	for ( string str : s3 ) ret.push(str)
	return ret
}

string[] concat( string[] s1, string[] s2, string[] s3, string[] s4 ) {
	string[] ret	
	for ( string str : s1 ) ret.push(str)
	for ( string str : s2 ) ret.push(str)
	for ( string str : s3 ) ret.push(str)
	for ( string str : s4 ) ret.push(str)
	return ret
}

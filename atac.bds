#!/usr/bin/env bds


help == atac pipeline settings

se 		:= false 	help Single ended data.
trimmed_fastq 	:= false	help Skip fastq-trimming stage.
fraglen 	:= 75 		help Read fragment length (default: 75).
mapping	 	:= false	help Mapping only (no macs2 peak calling or idr).
vplot 		:= false 	help Create V plot.
preseq 		:= false 	help Do preseq analysis.
subsample 	:= false 	help Subsample replicates. Use '-nreads [NO_READS]' (default: 15000000) to specify # reads to subsample.
pseudorep 	:= false 	help Generate pseudo-replicates and call peaks on them.
idr 		:= false 	help Perform IDR analysis.
ataqc 		:= false 	help Advanced ATAC QC (parameters to be defined: species, blacklist, dnase, tss, prom, enh, reg2map and roadmap_meta).

help() // show help contexts

include "chipseq/modules/input_fastq.bds"
include "chipseq/modules/input_bam.bds"
include "chipseq/modules/align_bowtie2.bds"
include "chipseq/modules/align_etc.bds"
include "chipseq/modules/vplot.bds"
include "chipseq/modules/postalign_bam.bds"
include "chipseq/modules/postalign_bed.bds"
include "chipseq/modules/preseq.bds"
include "chipseq/modules/callpeak_macs2.bds"
include "chipseq/modules/idr.bds"

input := ""

// Global variable for output filenames ( map with key $rep )
string{} peaks, peaks_pr1, peaks_pr2 	
string{} shifted_tags, shifted_tags_pr1, shifted_tags_pr2



init_atac()

chk_input_data()

set_shell_env()

atac()

do_idr()


void init_atac() {

	if ( conf_file_exists() ) {

		se 		= get_conf_val_bool( se,		["se"] )

		trimmed_fastq 	= get_conf_val_bool( trimmed_fastq,	["trimmed_fastq"] )
		fraglen 	= get_conf_val_int( fraglen,		["fraglen", "frag_len"] )

		mapping		= get_conf_val_bool( mapping,		["mapping"] )

		vplot 		= get_conf_val_bool( vplot,		["vplot"] )
		preseq 		= get_conf_val_bool( preseq,		["preseq"] )
		subsample	= get_conf_val_bool( subsample, 	["subsample"] )
		pseudorep	= get_conf_val_bool( pseudorep, 	["pseudorep"] )

		idr 		= get_conf_val_bool( idr, 		["idr"] )
		ataqc 		= get_conf_val_bool( ataqc, 		["ataqc"] )
	}
	else if ( is_input_legacy() ) { // legacy input method taking first 8 parameters from cmd. line

		bwt2_idx 	= args[0].trim()
		fastq1_1	= args[1].trim()
		fastq1_2	= args[2].trim()
		nth_bwt2	= args[3].trim().parseInt()
		gensz		= args[4].trim()
		chrsz		= args[5].trim()
		vplot_idx 	= args[6].trim()
		out_dir 	= args[7].trim()

		se 		= false

		vplot 		= true
		preseq 		= true

		mapping 	= false

		idr 		= false
		ataqc 		= false

		input 		= "fastq"
	
		print("\n\nLegacy input method found (8 parameters)\n")
		print("========================================\n")
		print( "Bowtie2 index\t\t: $bwt2_idx\n" )
		print( "Read 1\t\t\t: $fastq1_1\n" )
		print( "Read 2\t\t\t: $fastq1_2\n" )
		print( "# threads (bowtie2)\t: $nth_bwt2\n")
		print( "Genome size (hs,mm)\t: $gensz\n" )
		print( "Chromosome sizes file\t: $chrsz\n" )
		print( "V-Plot index\t\t: $vplot_idx\n" )
		print( "Output dir.\t\t: $out_dir\n" )
	}

	if ( input == "" ) { // determine input type
		
		if ( get_filt_bam(0,1) != "" ) 	input = "filt_bam"
		if ( get_bam(0,1) != "" ) 	input = "bam"
		if ( get_fastq(0,1,1) != "" ) 	input = "fastq"
	}

	fraglen0 = true // set fragment length as zero for cross corr. analysis

	print( "\n\n== atac pipeline settings\n")
	print( "Single ended data set?\t: $se\n")
	print( "Input data type\t\t: $input\n")		
	print( "Fastqs are trimmed?\t: $trimmed_fastq\n")
	print( "Fragment length\t\t: $fraglen\n")
	print( "# Replicates\t\t: "+ get_num_rep() + "\n")
	print( "MACS2 peak calling\t: " + !mapping + "\n")
	print( "Subsample replicates\t: $subsample\n")
	print( "Create/call peaks on pseudo replicates\t: $pseudorep\n")
	print( "Perform IDR analysis on peaks\t: $idr\n")
	print( "Vplot generation\t: $vplot\n")
	print( "Preseq analysis\t\t: $preseq\n")
	print( "ATAQC (advanced QC report including vplot and preseq)\t: $ataqc\n")
}

void chk_input_data() {

	print( "\n\n== checking atac inputs (data type = $input) ...\n\n" );

	if ( is_input_fastq() ) chk_align_bwt2()
	if ( !mapping ) 	chk_callpeak_macs2()
	if ( vplot ) 		chk_vplot()
	if ( idr ) 		chk_idr()

	if ( is_input_filt_bam() && ( vplot || preseq ) ) {
		error("Preseq analysis (-preseq) and vplot (-vplot) are not available if pipeline starts from filtered bam files (with '-input filt_bam')!\n")
	}

	if ( ataqc && !is_input_fastq() ) error("ATACQC (-ataqc) is available for fastqs input only!\n")
	if ( ataqc && se ) 		  error("ATACQC (-ataqc) is not available for single-ended (-se) data set!\n")

	// check data files
	suffix := se ? " (SE)" : " (PE)"

	string[] data_all

	for ( int rep=1; rep <= get_num_rep(); rep++) {

		string[] data

		string prefix

		if ( is_input_fastq() ) {
			prefix = "Rep$rep fastq" + suffix
			fastqs := get_fastqs( 0, rep )

			if ( !se && (get_num_rep()==1) && (fastqs.size()<2) && (get_fastq( 0, 2, 1 )!="") ) fastqs.add( get_fastq( 0, 2, 1 ) )

			if ( !se && fastqs.size() < 2 ) error("A pair of fastqs are needed for replicate $rep (if it's single-ended add '-se')\n")

			if ( fastqs.size()==0 ) {
				data.push( "" )
			}
			else {
				for ( string fastq : fastqs ) data.push( fastq )
			}

			if ( fastqs.size()==0 ) error("No fastq defined for replicate $rep\n")
		}
		else if ( is_input_bam() ) {
			prefix = "Rep$rep bam" + suffix
			data.push( get_bam( 0, rep ) )
		}
		else if ( is_input_filt_bam() ) {
			prefix = "Rep$rep filt_bam" + suffix
			data.push( get_filt_bam( 0, rep ) )
		}
		else {
			error("Unspported input type (-input)!")
		}

		print("$prefix :\n")

		for ( string s : data ) {
			print("\t$s\n")
			if ( (s != "") && !path_exists(s) ) error("\t\tFile not found!\n")
		}

		if ( data[0] == "" ) {
			error( "\t$prefix missing!\n")
		}

		// check any duplicate input filename
		for ( string s : data ) {
			if ( is_in_array( get_basename( s ), get_basename( data_all ) ) ) \
				error( "\t$prefix has duplicate filename!\n")
		}

		data_all = concat( data_all, data )
	}

}

void atac() {

	for (int rep=1; rep<=get_num_rep(); rep++) {
		
		if ( no_par )   _atac( rep )
		else 		par _atac( rep )
	}
	wait
}

void _atac( int rep ) {

	if ( se ) 	_atac_SE( rep )
	else 		_atac_PE( rep )
}

void _atac_SE( int rep ) {

	info := get_task_info( 0, rep )

	atac_out_dir := mkdir_path( (get_num_rep()==1) ? out_dir : "$out_dir/$info" )

	string fastq, align_log, bam, filt_bam, dup_qc

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )

		fastq = fastqs[0]

		string p1
		
		if ( trimmed_fastq ) {
			p1 = fastq
		}
		else {
			p1 = _trim_adapters( fastq, atac_out_dir, info )
		}
		wait

		( bam, align_log ) = _bowtie2( p1, atac_out_dir, info )
		wait
	}

	if ( is_input_fastq() || is_input_bam() ) {

		if ( is_input_bam() ) bam = get_bam( 0, rep )			

		( filt_bam, dup_qc ) = _dedup_bam( bam, atac_out_dir, info )
		wait
	}


	if ( is_input_fastq() || is_input_bam() || is_input_filt_bam() ) {

		if ( is_input_filt_bam() ) filt_bam = get_filt_bam( 0, rep )
	}

	string pval_bigwig, fc_bigwig

	string subsampled_tag

	if ( !mapping ) {

		tag := _bam_to_tag( filt_bam, atac_out_dir, info )
		wait

		if ( subsample ) {
			subsampled_tag = _subsample_tag( tag, atac_out_dir, info )
			wait
		}
		else {
			subsampled_tag = tag
		}

		shifted_tags{rep} = _shift_tag( subsampled_tag, atac_out_dir, info )
		wait

		( peaks{rep}, fc_bigwig, pval_bigwig )  = _macs2_atac( shifted_tags{rep}, "$fraglen", atac_out_dir, info )

		if ( pseudorep ) {

			( shifted_tags_pr1{rep}, shifted_tags_pr2{rep} ) = _spr( shifted_tags{rep}, atac_out_dir, info )
			wait

			string tmp // to get multiple elements of function return
			( peaks_pr1{rep}, tmp ) = _macs2_atac( shifted_tags_pr1{rep}, "$fraglen", atac_out_dir, info + "_pr1" )
			( peaks_pr2{rep}, tmp ) = _macs2_atac( shifted_tags_pr2{rep}, "$fraglen", atac_out_dir, info + "_pr2")
		}
	}

	if ( bam != "" ) {

		string sorted_bam

		if ( vplot || preseq || ataqc ) sorted_bam = _srt_bam( bam, atac_out_dir, info )
		wait

		if ( ataqc ) {
			// currently ataqc doesn't support single ended data
		}
		else {

			if ( vplot ) _vplot( sorted_bam, atac_out_dir, info )

			if ( preseq ) _preseq( sorted_bam, atac_out_dir, info )

			wait

			_report_atac( atac_out_dir, info )
		}		
	}

	if ( !mapping && subsampled_tag != "" ) { // cross correlation analysis

		_xcor( subsampled_tag, atac_out_dir, info )
	}

	wait
}

void _atac_PE( int rep ) {

	info := get_task_info( 0, rep )

	atac_out_dir := mkdir_path( (get_num_rep()==1) ? out_dir : "$out_dir/$info" )

	string fastq1, fastq2, align_log, bam, filt_bam, dup_qc

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )

		string p1, p2

		// correct if user skipped replicate id like (-fastq[PAIR]) instead of (-fastq[REP]_[PAIR])
		if ( (get_num_rep()==1) && (fastqs.size()<2) && (get_fastq( 0, 2, 1 )!="") ) fastqs.add( get_fastq( 0, 2, 1 ) )
 
		fastq1 = fastqs[0]
		fastq2 = fastqs[1]

		if ( trimmed_fastq ) {
			p1 = fastq1
			p2 = fastq2
		}
		else {
			( p1, p2 ) = _trim_adapters_PE( fastq1, fastq2, atac_out_dir, info )
			wait
		}

		( bam, align_log ) = _bowtie2_PE( p1, p2, atac_out_dir, info )
		wait
	}


	if ( is_input_fastq() || is_input_bam() ) {

		if ( is_input_bam() ) bam = get_bam( 0, rep )			

		(filt_bam, dup_qc) = _dedup_bam_PE( bam, atac_out_dir, info )
		wait
	}

	if ( is_input_fastq() || is_input_bam() || is_input_filt_bam() ) {

		if ( is_input_filt_bam() ) filt_bam = get_filt_bam( 0, rep )
	}

	string pval_bigwig, fc_bigwig

	if ( !mapping ) {

		if ( subsample || pseudorep ) {

			nmsrt_bam := _nmsrt_bam( filt_bam, atac_out_dir, info )
			wait

			bedpe := _bam_to_bedpe( nmsrt_bam, atac_out_dir, info )
			wait 

			string subsampled_bedpe

			if ( subsample ) {

				subsampled_bedpe = _subsample_bedpe( bedpe, atac_out_dir, info )		
			}
			else {
				subsampled_bedpe = bedpe
			}
			wait

			tag := _bedpe_to_tag( subsampled_bedpe, atac_out_dir, info )			
			wait

			shifted_tags{rep} = _shift_tag( tag, atac_out_dir, info )			 
			
			if ( pseudorep ) {

				string tag_pr1, tag_pr2
				(tag_pr1, tag_pr2) = _spr_PE( subsampled_bedpe, atac_out_dir, info )
				wait

				shifted_tags_pr1{rep} = _shift_tag( tag_pr1, atac_out_dir, info )
				shifted_tags_pr2{rep} = _shift_tag( tag_pr2, atac_out_dir, info )
			}
			wait

			( peaks{rep}, fc_bigwig, pval_bigwig )  = _macs2_atac( shifted_tags{rep}, "$fraglen", atac_out_dir, info )
			
			if ( pseudorep ) {

				string tmp // to get multiple elements of function return
				( peaks_pr1{rep}, tmp ) = _macs2_atac( shifted_tags_pr1{rep}, "$fraglen", atac_out_dir, info + "_pr1" )
				( peaks_pr2{rep}, tmp ) = _macs2_atac( shifted_tags_pr2{rep}, "$fraglen", atac_out_dir, info + "_pr2")
			}
		}
		else {

			shifted_tags{rep} = _bam_to_bed_atac( filt_bam, atac_out_dir, info )
			wait

			( peaks{rep}, fc_bigwig, pval_bigwig ) = _macs2_atac( shifted_tags{rep}, "$fraglen", atac_out_dir, info )
		}
	}

	if ( bam != "" ) {

		string sorted_bam

		if ( vplot || preseq || ataqc ) sorted_bam = _srt_bam( bam, atac_out_dir, info )
		wait

		if ( ataqc ) {

			report_dir := mkdir_path( "$atac_out_dir/ataqc" )

			_ataqc( fastq1, fastq2, bam, align_log, sorted_bam, \
				dup_qc, filt_bam, shifted_tags{rep}, pval_bigwig, peaks{rep}, \
				report_dir, info )
		}
		else {

			if ( vplot ) _vplot( sorted_bam, atac_out_dir, info )

			if ( preseq ) _preseq( sorted_bam, atac_out_dir, info )

			wait

			_report_atac( atac_out_dir, info )
		}
	}

	wait
}

void do_idr() {
	
	if ( !idr || get_num_rep() != 2 ) return

	idr_out_dir := mkdir_path( use_idr1 ? "$out_dir/idr1" : "$out_dir/idr2" )

	shifted_tag_pooled := _pool_tag( shifted_tags{1}, shifted_tags{2}, idr_out_dir, "" )
	wait

	peak_pooled := _macs2_atac( shifted_tag_pooled, "$fraglen", idr_out_dir, "pooled" )
	wait

	// IDR for true reps
	idr_Nt := _idr( peaks{1}, peaks{2}, peak_pooled, idr_out_dir, "true_rep_Rep1_vs_Rep2" )

	if ( pseudorep ) {

		// IDR on pseudo reps
		idr_N1 := _idr( peaks_pr1{1}, peaks_pr2{1}, peaks{1}, idr_out_dir, "pseudo_rep_Rep1_PR1_vs_Rep1_PR2" )
		idr_N2 := _idr( peaks_pr1{2}, peaks_pr2{2}, peaks{2}, idr_out_dir, "pseudo_rep_Rep2_PR1_vs_Rep2_PR2" )

		// Make shifted tags for pooled pseudo rep (ppr).
		string shifted_tag_pooled, shifted_tag_ppr1, shifted_tag_ppr2

		( shifted_tag_pooled, shifted_tag_ppr1, shifted_tag_ppr2 ) = \
			_ppr( 	shifted_tags{1}, shifted_tags_pr1{1}, shifted_tags_pr2{1}, \
				shifted_tags{2}, shifted_tags_pr1{2}, shifted_tags_pr2{2}, idr_out_dir, "" )
		wait

		// call peaks on ppr
		peak_ppr1 := _macs2_atac( shifted_tag_ppr1, "$fraglen", idr_out_dir, "ppr1" )
		peak_ppr2 := _macs2_atac( shifted_tag_ppr2, "$fraglen", idr_out_dir, "ppr2" )
		wait

		// IDR on ppr
		idr_Np := _idr( peak_ppr1, peak_ppr2, peak_pooled, idr_out_dir, "pooled_pseudo_rep_PPR1_vs_PPR2" )
		wait

		if ( path_exists( blacklist_idr ) ) {
			// second entry of return from function _idr() is narrowpeak.gz, get final idr qc score
			idr_final_score := _idr_final_qc( idr_Nt[1], idr_N1[1], idr_N2[1], idr_Np[1], idr_out_dir, "" )
		}
	}

	wait
}

string[] _ataqc( string fastq1, string fastq2, string bam, string align_log, string srt_bam, \
		 string dup_log, string filt_bam, string bed, string bigwig, string peak, \
		 string out_dir, string info ) {

	prefix 		:= change_dir( remove_ext( fastq1, ["fastq","fq"] ), out_dir ) + ".PE2SE"

	html 		:= "$prefix"+"_qc.html"
	txt 		:= "$prefix"+"_qc.txt"
	/*
	gc_plot 	:= "$prefix"+"_gcPlot.pdf"
	hist_graph 	:= "$prefix.inserts.hist_graph.pdf"
	lg_vplot 	:= "$prefix"+"_large_vplot.png"
	vplot 		:= "$prefix"+"_vplot.png"
	signal 		:= "$prefix.signal"
	*/

	prefix_basename := get_basename( prefix )

	in  := [ fastq1, fastq2, bam, align_log, srt_bam, dup_log, filt_bam, bed, bigwig, peak ]
	out := [ html, txt ] //, gc_plot, hist_graph, lg_vplot, vplot, signal ]

	task( taskName:= "ataqc "+info, \
		cpus:=nth, mem:=parse_mem_or_skip(memory), timeout:=parse_time_or_skip(wt), \
		out<-in ) {

		sys $SHCMD_INIT

		sys cd $out_dir

		sys python $(which run_ataqc.py) \
		    --workdir $out_dir \
		    --outdir $out_dir \
		    --outprefix $prefix_basename \
		    --genome $species \
		    --ref $ref_fa \
		    --tss $tss \
		    --dnase $dnase \
		    --blacklist $blacklist \
		    --prom $prom \
		    --enh $enh \
		    --reg2map $reg2map \
		    --meta $roadmap_meta \
		    --fastq1 $fastq1 \
		    --fastq2 $fastq2 \
		    --alignedbam $bam \
		    --alignmentlog $align_log \
		    --coordsortbam $srt_bam \
		    --duplog $dup_log \
		    --finalbam $filt_bam \
		    --finalbed $bed \
		    --bigwig $bigwig \
		    --peaks $peak
	}

	wait_par()

	return out
}

// outputs (pdf, png, log, ...) and report must be in the same directory
string[] _report_atac( string out_dir, string info ) {

	//prefix   := change_dir( remove_ext( preseq_pdf, ["preseq.pdf"] ), out_dir )
	//tex_file := "$prefix.summary.tex"
	//pdf_file := "$prefix.summary.pdf"

	prefix 	 := "$out_dir/report"
	tex_file := "$prefix.tex"
	pdf_file := "$prefix.pdf"

	in 	:= "" // always run this function (don't check file time stamp)
	out 	:= [tex_file, pdf_file]

	task( taskName:= "report "+info, \
		cpus:=nth, mem:=parse_mem_or_skip(memory), timeout:=parse_time_or_skip(wt), \
		out<-in ) {

		sys $SHCMD_INIT

		sys cd $out_dir
		sys thisFolder=$out_dir

		//# figure out what we've aligned to
		sys MODEL=$bwt_idx

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys if [[ $input == "fastq" ]]; then \
			alignLog="$(echo *.align.log)"; \
			alignLogLastLine=$(tail -n 1 ${alignLog}); \
			fi

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys if [[ $input == "fastq" ]]; then \
			dupQCFile=$(echo *.dup.qc); \
			dupQCHeadings=$(sed -n 7p ${dupQCFile}); \
			dupQCHeadings=${dupQCHeadings//_/\\\\_}; \
			IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"; \
			dupQCData=$(sed -n 8p ${dupQCFile}); \
			IFS=$'\t' read -a dupQCData <<< "${dupQCData}"; \
			START=0; \
			END=${#dupQCHeadings[@]}; \
			DUPTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			bpcQCFile=$(echo *.pbc.qc); \
			declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair"); \
			bpcQC=$(cat ${bpcQCFile}); \
			IFS=$'\t' read -a bpcData <<< "${bpcQC}"; \
			START=0; \
			END=${#bpcLabels[@]}; \
			BPCTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			fi

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $tex_file
		sys echo "\usepackage{graphicx}" >> $tex_file
		sys echo "\usepackage{multicol}" >> $tex_file
		sys echo "\usepackage{listings}" >> $tex_file
		sys echo "\usepackage{grffile}" >> $tex_file
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $tex_file
		sys echo "\usepackage{booktabs}" >> $tex_file
		sys echo "\usepackage{hyphenat}" >> $tex_file
		sys echo "\usepackage{fancyhdr}" >> $tex_file
		sys echo "\pagestyle{fancy}" >> $tex_file
		sys echo "\fancyhf{}" >> $tex_file
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $tex_file
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $tex_file
		sys echo "\begin{document}" >> $tex_file
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $tex_file
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $tex_file
		sys echo "\begin{multicols}{2}" >> $tex_file
		sys echo "\subsection{Genome Model}" >> $tex_file
		sys echo "${MODEL//_/\\_}" >> $tex_file

		sys if [[ ${vPlot} != "*"* ]]; then \
			echo "\subsection{V-Plot}" >> $tex_file; \
			echo "From ${vPlot//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $tex_file; \
			fi

		sys if [[ ${preseqGraph} != "*"* ]]; then \
			echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $tex_file; \
			echo "From ${preseqGraph//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $tex_file; \
			fi

		//if [[ $preseqLog != "*"* ]];

		sys if [[ $input == "fastq" ]]; then \
			echo "\subsection{Library Complexity}" >> $tex_file; \
			echo "From ${bpcQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\centerline{" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${BPCTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "}" >> $tex_file; \
			if [[ ${insertSizeHist} != "*"* ]]; then \
				echo "\subsection{Insert size histogram}" >> $tex_file; \
				echo "From ${insertSizeHist//_/\\_}:\\\\" >> $tex_file; \
				echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $tex_file; \
				fi; \
			echo "\subsection{Picard Duplication Metrics}" >> $tex_file; \
			echo "From ${dupQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${DUPTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "\subsection{bowtie2 Alignment Log}" >> $tex_file; \
			echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $tex_file; \
			echo "From ${alignLog//_/\\_}:\\\\" >> $tex_file; \
			echo "\scalebox{.6}{" >> $tex_file; \
			echo "\lstinputlisting{${alignLog}}" >> $tex_file; \
			echo "}" >> $tex_file; \
			fi

		sys echo "\end{multicols}  " >> $tex_file
		sys echo "%\pagebreak" >> $tex_file
		sys echo "\end{document}" >> $tex_file		

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $out_dir
		sys pdflatex $tex_file
	}

	return out
}

void set_shell_env() {
	
	// create output dir.	

	if ( is_kundaje_lab() || is_scg3() ) {

		print("\n\nAutomatically adding environment variables... (kundaje_lab: $hostname) \n\n")

		if ( SHCMD_INIT.indexOf( init_mod ) < 0  ) { // if not module init. cmd found, then add it
			SHCMD_INIT = SHCMD_INIT + " . /etc/profile.d/modules.sh;"
		}

		if ( is_scg3() ) { // if on SCG3		

			SHCMD_INIT = SHCMD_INIT + " module add gnuplot/5.0 python/2.7.6;" \

			dir_sw_BDS := "/srv/gsfs0/scratch/leepc12/software"

			path := " export PATH=" \
				+ "$dir_sw_BDS/R-2.15.1/bin:" \
				+ "$dir_sw_BDS/phantompeakqualtools:$dir_sw_BDS/python3.4/bin:" \
				+ "$dir_sw_BDS/idrCode" \
				+ "\${PATH}"

			shellcmd := "export LAPACK=$dir_sw_BDS/blas/lapack-*/liblapack.a;"
			
			SHCMD_INIT = SHCMD_INIT + ";" + path + ";" + shellcmd
			SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )			
		}
		else {
			SHCMD_INIT = SHCMD_INIT + " module add r/2.15.1 phantompeakqualtools/default idr/latest trim_galore/0.4.0;"
			SHCMD_INIT = SHCMD_INIT + " export PATH=${PATH}:/software/idrCode;"			
		}

		SHCMD_INIT = SHCMD_INIT + " module add bowtie/2.2.4 samtools/1.2 bedtools/2.21.0;" \
					+ " module add picard-tools/1.129 ucsc_tools/3.0.9 MACS2/2.1.0 java/latest;" \
					+ " module add preseq/1.0.2 texlive/2013;" \
					+ " export _JAVA_OPTIONS='-Xms256M -Xmx2048M -XX:ParallelGCThreads=1'; export MAX_JAVA_MEM='16G'; export MALLOC_ARENA_MAX=4"
		SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )

		print( "Shell command for init.\t: $SHCMD_INIT\n" )
	}
}

void help() {

	if ( is_cmd_line_arg_empty() ) {

		printHelp()
		exit
	}
}

string get_task_info( int ctl, int rep ) {

	return ( (ctl>0) ? "ctl_" : "") + "rep" + rep
}

bool is_input_legacy() {

	bool ret

	if ( args.size() >= 8 ) {
		ret = true

		for (int i=0; i<8;i++) {
			
			if ( args[i].startsWith("-") ) {
				ret = false
				break
			}
		}
	}

	return ret
}

bool is_input_fastq() {

	return input.toLower() == "fastq"
}

bool is_input_bam() {

	return input.toLower() == "bam"
}

bool is_input_filt_bam() {

	return input.toLower() == "filt_bam"
}

int get_num_rep() {

	if ( is_input_legacy() ) {
		return 1
	}
	else if ( is_input_fastq() ) {

		if ( get_num_rep_fastq()==2 ) {

			fastqs := get_fastqs( 0, 1 )			

			if ( !se && fastqs.size()<2 ) return 1
		}

		return get_num_rep_fastq()
	}
	else if ( is_input_bam() )  	return get_num_rep_bam()
	else if ( is_input_filt_bam() ) return get_num_rep_filt_bam()

	return 0
}
